@color #AA99AF
xmcu {}
module xmcu
module STM32C051

peripherals {
	@color #9b2316
	@brief ADC address block description
	ADC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x30C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40012400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief ADC interrupt and status register
		ADC_ISR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC ready\nThis bit is set by hardware after the ADC has been enabled (ADEN = 1) and when the ADC reaches a state where it is ready to accept conversion requests.\nIt is cleared by software writing 1 to it.
			ADRDY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of sampling flag\nThis bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to  1 .
			EOSMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of conversion flag\nThis bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.
			EOC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of sequence flag\nThis bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
			EOS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC overrun\nThis bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.
			OVR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 1 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.
			AWD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 2 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.
			AWD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 3 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.
			AWD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End Of Calibration flag\nThis bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.
			EOCAL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel Configuration Ready flag\nThis flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it.\nNote: When the softwa
			CCRDY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC interrupt enable register
		ADC_IER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC ready interrupt enable\nThis bit is set and cleared by software to enable/disable the ADC Ready interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
			ADRDYIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of sampling flag interrupt enable\nThis bit is set and cleared by software to enable/disable the end of the sampling phase interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is o
			EOSMPIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of conversion interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
			EOCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of conversion sequence interrupt enable\nThis bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conv
			EOSIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun interrupt enable\nThis bit is set and cleared by software to enable/disable the overrun interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
			OVRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 1 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
			AWD1IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 2 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
			AWD2IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 3 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
			AWD3IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of calibration interrupt enable\nThis bit is set and cleared by software to enable/disable the end of calibration interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing).
			EOCALIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel Configuration Ready Interrupt enable\nThis bit is set and cleared by software to enable/disable the channel configuration ready interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conver
			CCRDYIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC control register
		ADC_CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC enable command\nThis bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set.\nIt is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.\nNote: The software is
			ADEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC disable command
			ADDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC start conversion command\nThis bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware tr
			ADSTART {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC stop conversion command
			ADSTP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC Voltage Regulator Enable\nThis bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after t<sub>ADCVREG_STUP</sub>.\nIt is cleared by software to disable the voltage regulator. It can be cleared
			ADVREGEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC calibration\nThis bit is set by software to start the calibration of the ADC.\nIt is cleared by hardware after calibration is complete.\nNote: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 
			ADCAL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC configuration register 1
		ADC_CFGR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Direct memory access enable\nThis bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to Section 16.6.5: Managing convert
			DMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Direct memory access configuration\nThis bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN = 1.\nFor more details, refer to Section 16.6.5: Managing converted data using the DMA on page 325.
			DMACFG {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Scan sequence direction\nThis bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared.\nNote: If CCRDY is not yet asserted after channel configuration (writ
			SCANDIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data resolution\nThese bits are written by software to select the resolution of the conversion.
			RES {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data alignment\nThis bit is set and cleared by software to select right or left alignment. Refer to Figure 43: Data alignment and resolution (oversampling disabled: OVSE = 0) on page 323
			ALIGN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger selection\nThese bits select the external event used to trigger the start of conversion (refer to Table 67: External triggers for details):
			EXTSEL {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger enable and polarity selection\nThese bits are set and cleared by software to select the external trigger polarity and enable the trigger.
			EXTEN {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun management mode\nThis bit is set and cleared by software and configure the way data overruns are managed.
			OVRMOD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Single / continuous conversion mode\nThis bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared.\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to se
			CONT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wait conversion mode\nThis bit is set and cleared by software to enable/disable wait conversion mode.<sup>.</sup>
			WAIT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-off mode\nThis bit is set and cleared by software to enable/disable auto-off mode.<sup>.</sup>
			AUTOFF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Discontinuous mode\nThis bit is set and cleared by software to enable/disable discontinuous mode.\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN = 1 and CONT = 1.
			DISCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mode selection of the ADC_CHSELR register\nThis bit is set and cleared by software to control the ADC_CHSELR feature:\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value w
			CHSELRMOD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable the watchdog on a single channel or on all channels\nThis bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels
			AWD1SGL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog enable\nThis bit is set and cleared by software.
			AWD1EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.\n.....\nOthers: Reserved\nNote: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR reg
			AWD1CH {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC configuration register 2
		ADC_CFGR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Oversampler Enable\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADEN bit is cleared.
			OVSE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling ratio\nThis bit filed defines the number of oversampling ratio.\nNote: The software is allowed to write this bit only when ADEN bit is cleared.
			OVSR {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling shift\nThis bit is set and cleared by software.\nOthers: Reserved\nNote: The software is allowed to write this bit only when ADEN bit is cleared.
			OVSS {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Triggered Oversampling\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADEN bit is cleared.
			TOVS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low frequency trigger mode enable\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADEN bit is cleared.
			LFTRIG {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC clock mode\nThese bits are set and cleared by software to define how the analog ADC is clocked:\nIn all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion.\nNote: The software is allowed to write th
			CKMODE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC sampling time register
		ADC_SMPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Sampling time selection 1\nThese bits are written by software to select the sampling time that applies to all channels.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
			SMP1 {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Sampling time selection 2\nThese bits are written by software to select the sampling time that applies to all channels.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
			SMP2 {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL17 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL18 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL19 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL20 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL21 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection (x = 22 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).\nNote: Refer to S
			SMPSEL22 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC watchdog threshold register
		ADC_AWD1TR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog 1 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to Section 16.8: Analog window watchdogs on page 329.
			LT1 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 1 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to Section 16.8: Analog window watchdogs on page 329.
			HT1 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC watchdog threshold register
		ADC_AWD2TR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog 2 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to Section 16.8: Analog window watchdogs on page 329.
			LT2 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 2 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to Section 16.8: Analog window watchdogs on page 329.
			HT2 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC channel selection register
		ADC_CHSELR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL17 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL18 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL19 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL20 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL21 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to Figure 35: ADC connectivity for ADC inputs connected to external channels and internal sources.\nNote: The softw
			CHSEL22 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC channel selection register
		ADC_CHSELR_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 1st conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ1 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 2nd conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ2 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 3rd conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ3 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 4th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ4 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 5th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ5 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 6th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ6 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 7th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ7 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 8th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequen
			SQ8 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC watchdog threshold register
		ADC_AWD3TR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog 3lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to Section 16.8: Analog window watchdogs on page 329.
			LT3 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 3 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to Section 16.8: Analog window watchdogs on page 329.
			HT3 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC data register
		ADC_DR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Converted data\nThese bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in Figure 43: Data alignment and resolution (oversampling disabled: OVSE = 0) on page 323.\nJust after
			DATA {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC analog watchdog 2 configuration register
		ADC_AWD2CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xA0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH17 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH18 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH19 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH20 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH21 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH22 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC Analog Watchdog 3 Configuration register
		ADC_AWD3CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xA4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH17 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH18 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH19 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH20 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH21 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH22 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC calibration factor
		ADC_CALFACT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xB4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Calibration factor\nThese bits are written by hardware or by software.\nOnce a calibration is complete, they are updated by hardware with the calibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is 
			CALFACT {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC common configuration register
		ADC_CCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x308, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC prescaler\nSet and cleared by software to select the frequency of the clock to the ADC.\nOther: Reserved\nNote: Software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).
			PRESC {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief V<sub>REFINT</sub> enable\nThis bit is set and cleared by software to enable/disable the V<sub>REFINT</sub>.\nNote: Software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
			VREFEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Temperature sensor enable\nThis bit is set and cleared by software to enable/disable the temperature sensor.\nNote: Software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
			TSEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief CRC address block description
	CRC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x18, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40023000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief CRC data register
		CRC_DR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Data register bits\nThis register is used to write new data to the CRC calculator.\nIt holds the previous CRC calculation result when it is read.\nIf the data size is less than 32 bits, the least significant bits are used to write/read the correct value.
			DR {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief CRC independent data register
		CRC_IDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief General-purpose 32-bit data register bits\nThese bits can be used as a temporary storage location for four bytes.\nThis register is not affected by CRC resets generated by the RESET bit in the CRC_CR register
			IDR {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief CRC control register
		CRC_CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief RESET bit\nThis bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware
			RESET {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Polynomial size\nThese bits control the size of the polynomial.
			POLYSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Reverse input data\nThis bitfield controls the reversal of the bit order of the input data
			REV_IN {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Reverse output data\nThis bit controls the reversal of the bit order of the output data.
			REV_OUT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief CRC initial value
		CRC_INIT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Programmable initial CRC value\nThis register is used to write the CRC initial value.
			CRC_INIT {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief CRC polynomial
		CRC_POL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Programmable polynomial\nThis register is used to write the coefficients of the polynomial to be used for CRC calculation.\nIf the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.
			POL {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief DBG address block description
	DBG {
		ec.Peripheral : {0}
		ec.Size : {size : {0x10, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40015800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief DBG device ID code register
		DBG_IDCODE {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Device identifier\nThis field indicates the device ID. Refer to Table 152.
			DEV_ID {
				ec.Access : {R}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Revision identifier\nThis field indicates the revision of the device. Refer to Table 152.
			REV_ID {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DBG configuration register
		DBG_CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00000004, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Debug Stop mode\nDebug options in Stop mode.\nUpon Stop mode exit, the software must re-establish the desired clock configuration.
			DBG_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Debug Standby and Shutdown modes\nDebug options in Standby or Shutdown mode.
			DBG_STANDBY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DBG APB freeze register 1
		DBG_APB_FZ1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clocking of TIM2 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM2 when the core is halted:\nThis bit is only available on STM32C071xx. On the other devices, it is reserved.
			DBG_TIM2_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clocking of TIM3 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM3 when the core is halted:
			DBG_TIM3_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clocking of RTC counter when the core is halted\nThis bit enables/disables the clock to the counter of RTC when the core is halted:
			DBG_RTC_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clocking of WWDG counter when the core is halted\nThis bit enables/disables the clock to the counter of WWDG when the core is halted:
			DBG_WWDG_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clocking of IWDG counter when the core is halted\nThis bit enables/disables the clock to the counter of IWDG when the core is halted:
			DBG_IWDG_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBUS timeout when core is halted
			DBG_I2C1_SMBUS_TIMEOUT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DBG APB freeze register 2
		DBG_APB_FZ2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clocking of TIM1 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM1 when the core is halted:
			DBG_TIM1_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clocking of TIM14 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM14 when the core is halted:
			DBG_TIM14_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clocking of TIM16 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM16 when the core is halted:
			DBG_TIM16_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clocking of TIM17 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM17 when the core is halted:
			DBG_TIM17_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief DMA register bank
	DMA {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40020000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief DMA interrupt status register
		DMA_ISR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Global interrupt flag for channel 1
			GIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete (TC) flag for channel 1
			TCIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer (HT) flag for channel 1
			HTIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error (TE) flag for channel 1
			TEIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Global interrupt flag for channel 2
			GIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete (TC) flag for channel 2
			TCIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer (HT) flag for channel 2
			HTIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error (TE) flag for channel 2
			TEIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Global interrupt flag for channel 3
			GIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete (TC) flag for channel 3
			TCIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer (HT) flag for channel 3
			HTIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error (TE) flag for channel 3
			TEIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 4
			GIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete (TC) flag for channel 4
			TCIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer (HT) flag for channel 4
			HTIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error (TE) flag for channel 4
			TEIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 5
			GIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete (TC) flag for channel 5
			TCIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer (HT) flag for channel 5
			HTIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error (TE) flag for channel 5
			TEIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA interrupt flag clear register
		DMA_IFCR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Global interrupt flag clear for channel 1
			CGIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete flag clear for channel 1
			CTCIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer flag clear for channel 1
			CHTIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error flag clear for channel 1
			CTEIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Global interrupt flag clear for channel 2
			CGIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete flag clear for channel 2
			CTCIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer flag clear for channel 2
			CHTIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error flag clear for channel 2
			CTEIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Global interrupt flag clear for channel 3
			CGIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete flag clear for channel 3
			CTCIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer flag clear for channel 3
			CHTIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error flag clear for channel 3
			CTEIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Global interrupt flag clear for channel 4
			CGIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete flag clear for channel 4
			CTCIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer flag clear for channel 4
			CHTIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error flag clear for channel 4
			CTEIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Global interrupt flag clear for channel 5
			CGIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete flag clear for channel 5
			CTCIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer flag clear for channel 5
			CHTIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error flag clear for channel 5
			CTEIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 1 configuration register
		DMA_CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, thi
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identif
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 1 number of data to transfer register
		DMA_CNDTR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Number of data to transfer (0 to 2<sup>16</sup> - 1)\nThis bitfield is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA  read followed by write  transfer, indicating the remaining amount of data items to transfer.\nIt
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 1 peripheral address register
		DMA_CPAR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] =
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 1 memory address register
		DMA_CMAR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bit
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 2 configuration register
		DMA_CCR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, thi
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identif
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 2 number of data to transfer register
		DMA_CNDTR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Number of data to transfer (0 to 2<sup>16</sup> - 1)\nThis bitfield is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA  read followed by write  transfer, indicating the remaining amount of data items to transfer.\nIt
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 2 peripheral address register
		DMA_CPAR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] =
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 2 memory address register
		DMA_CMAR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bit
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 3 configuration register
		DMA_CCR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, thi
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identif
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 3 number of data to transfer register
		DMA_CNDTR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Number of data to transfer (0 to 2<sup>16</sup> - 1)\nThis bitfield is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA  read followed by write  transfer, indicating the remaining amount of data items to transfer.\nIt
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 3 peripheral address register
		DMA_CPAR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] =
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 3 memory address register
		DMA_CMAR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bit
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 4 configuration register
		DMA_CCR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, thi
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identif
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 4 number of data to transfer register
		DMA_CNDTR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Number of data to transfer (0 to 2<sup>16</sup> - 1)\nThis bitfield is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA  read followed by write  transfer, indicating the remaining amount of data items to transfer.\nIt
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 4 peripheral address register
		DMA_CPAR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] =
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 4 memory address register
		DMA_CMAR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bit
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 5 configuration register
		DMA_CCR5 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x58, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, thi
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identif
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 5 number of data to transfer register
		DMA_CNDTR5 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x5C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Number of data to transfer (0 to 2<sup>16</sup> - 1)\nThis bitfield is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA  read followed by write  transfer, indicating the remaining amount of data items to transfer.\nIt
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 5 peripheral address register
		DMA_CPAR5 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] =
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 5 memory address register
		DMA_CMAR5 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x64, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bit
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief DMAMUX address block description
	DMAMUX {
		ec.Peripheral : {0}
		ec.Size : {size : {0x148, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40020800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief DMAMUX request line multiplexer channel 0 configuration register
		DMAMUX_C0CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
			DMAREQ_ID {
				ec.Access : {R|W}
				ec.Size : {size : {6, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization overrun interrupt enable
			SOIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation enable
			EGE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization enable
			SE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization polarity\nDefines the edge polarity of the selected synchronization input:
			SPOL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both S
			NBREQ {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization identification\nSelects the synchronization input (see Table 44: DMAMUX: assignment of synchronization inputs to resources).
			SYNC_ID {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request line multiplexer channel 1 configuration register
		DMAMUX_C1CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
			DMAREQ_ID {
				ec.Access : {R|W}
				ec.Size : {size : {6, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization overrun interrupt enable
			SOIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation enable
			EGE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization enable
			SE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization polarity\nDefines the edge polarity of the selected synchronization input:
			SPOL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both S
			NBREQ {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization identification\nSelects the synchronization input (see Table 44: DMAMUX: assignment of synchronization inputs to resources).
			SYNC_ID {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request line multiplexer channel 2 configuration register
		DMAMUX_C2CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
			DMAREQ_ID {
				ec.Access : {R|W}
				ec.Size : {size : {6, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization overrun interrupt enable
			SOIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation enable
			EGE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization enable
			SE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization polarity\nDefines the edge polarity of the selected synchronization input:
			SPOL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both S
			NBREQ {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization identification\nSelects the synchronization input (see Table 44: DMAMUX: assignment of synchronization inputs to resources).
			SYNC_ID {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request line multiplexer channel 3 configuration register
		DMAMUX_C3CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
			DMAREQ_ID {
				ec.Access : {R|W}
				ec.Size : {size : {6, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization overrun interrupt enable
			SOIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation enable
			EGE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization enable
			SE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization polarity\nDefines the edge polarity of the selected synchronization input:
			SPOL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both S
			NBREQ {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization identification\nSelects the synchronization input (see Table 44: DMAMUX: assignment of synchronization inputs to resources).
			SYNC_ID {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request line multiplexer channel 4 configuration register
		DMAMUX_C4CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.
			DMAREQ_ID {
				ec.Access : {R|W}
				ec.Size : {size : {6, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization overrun interrupt enable
			SOIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation enable
			EGE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization enable
			SE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization polarity\nDefines the edge polarity of the selected synchronization input:
			SPOL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both S
			NBREQ {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization identification\nSelects the synchronization input (see Table 44: DMAMUX: assignment of synchronization inputs to resources).
			SYNC_ID {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request line multiplexer interrupt channel status register
		DMAMUX_CSR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x080, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in
			SOF0 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in
			SOF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in
			SOF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in
			SOF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in
			SOF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request line multiplexer interrupt clear flag register
		DMAMUX_CFR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x084, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
			CSOF0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
			CSOF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
			CSOF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
			CSOF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.
			CSOF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request generator channel 0 configuration register
		DMAMUX_RG0CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x100, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator
			SIG_ID {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger overrun interrupt enable
			OIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator channel x enable
			GE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input
			GPOL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field must be written only when GE bit is disabled.
			GNBREQ {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request generator channel 1 configuration register
		DMAMUX_RG1CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x104, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator
			SIG_ID {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger overrun interrupt enable
			OIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator channel x enable
			GE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input
			GPOL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field must be written only when GE bit is disabled.
			GNBREQ {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request generator channel 2 configuration register
		DMAMUX_RG2CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x108, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator
			SIG_ID {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger overrun interrupt enable
			OIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator channel x enable
			GE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input
			GPOL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field must be written only when GE bit is disabled.
			GNBREQ {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request generator channel 3 configuration register
		DMAMUX_RG3CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator
			SIG_ID {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger overrun interrupt enable
			OIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator channel x enable
			GE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input
			GPOL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field must be written only when GE bit is disabled.
			GNBREQ {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request generator interrupt status register
		DMAMUX_RGSR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x140, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cle
			OF0 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cle
			OF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cle
			OF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cle
			OF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMUX request generator interrupt clear flag register
		DMAMUX_RGCFR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x144, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
			COF0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
			COF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
			COF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.
			COF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief EXTI address block description
	EXTI {
		ec.Peripheral : {0}
		ec.Size : {size : {0x98, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40021800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief EXTI rising trigger selection register 1
		EXTI_RTSR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x000, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line x (x = 15 to 0)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nNote: The configurable lines are edge triggered; no glitch must be generat
			RT15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI falling trigger selection register 1
		EXTI_FTSR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x004, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line x (x = 15 to 0).\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nThe configurable lines are edge triggered; no glitch must be generated 
			FT15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI software interrupt event register 1
		EXTI_SWIER1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x008, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line x (x = 15 to 0)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically 
			SWI15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI rising edge pending register 1
		EXTI_RPR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			RPIF15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI falling edge pending register 1
		EXTI_FPR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x010, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line x (x = 15 to 0)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.
			FPIF15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI rising trigger selection register 2
		EXTI_RTSR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x028, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rising trigger event configuration bit of configurable line 34\nEach bit enables/disables the rising edge trigger for the event and interrupt on the line 34.\nThis configurable line is edge triggered; no glitch must be generated on this inputs.\nNote: If a r
			RT34 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI falling trigger selection register 2
		EXTI_FTSR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x02C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line 34.\nEach bit enables/disables the falling edge trigger for the event and interrupt on the line 34.\nThe configurable lines are edge triggered; no glitch must be generated on these inputs.\nNote: I
			FT34 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI software interrupt event register 2
		EXTI_SWIER2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x030, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Software rising edge event trigger on line 34\nSetting of any bit by software triggers a rising edge event on the line 34, resulting in an interrupt, independently of EXTI_RTSR2 and EXTI_FTSR2 settings. The bits are automatically cleared by HW. Reading of 
			SWI34 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI rising edge pending register 2
		EXTI_RPR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x034, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rising edge event pending for configurable line 34\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER2 register) on the line 34. Each bit is cleared by writing 1 into it.
			RPIF34 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI falling edge pending register 2
		EXTI_FPR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x038, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Falling edge event pending for configurable line 34\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER2 register) on the line 34. Each bit is cleared by writing 1 into it.
			FPIF34 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI external interrupt selection register
		EXTI_EXTICR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI0 GPIO port selection\nThese bits are written by software to select the source input for EXTI0 external interrupt.\nOthers reserved
			EXTI0 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI1 GPIO port selection\nThese bits are written by software to select the source input for EXTI1 external interrupt.\nOthers reserved
			EXTI1 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI2 GPIO port selection\nThese bits are written by software to select the source input for EXTI2 external interrupt.\nOthers reserved
			EXTI2 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI3 GPIO port selection\nThese bits are written by software to select the source input for EXTI3 external interrupt.\nOthers reserved
			EXTI3 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI external interrupt selection register
		EXTI_EXTICR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x64, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI4 GPIO port selection\nThese bits are written by software to select the source input for EXTI4 external interrupt.\nOthers reserved
			EXTI4 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI5 GPIO port selection\nThese bits are written by software to select the source input for EXTI5 external interrupt.\nOthers reserved
			EXTI5 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI6 GPIO port selection\nThese bits are written by software to select the source input for EXTI6 external interrupt.\nOthers reserved
			EXTI6 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI7 GPIO port selection\nThese bits are written by software to select the source input for EXTI7 external interrupt.\nOthers reserved
			EXTI7 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI external interrupt selection register
		EXTI_EXTICR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI8 GPIO port selection\nThese bits are written by software to select the source input for EXTI8 external interrupt.\nOthers reserved
			EXTI8 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI9 GPIO port selection\nThese bits are written by software to select the source input for EXTI9 external interrupt.\nOthers reserved
			EXTI9 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI10 GPIO port selection\nThese bits are written by software to select the source input for EXTI10 external interrupt.\nOthers reserved
			EXTI10 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI11 GPIO port selection\nThese bits are written by software to select the source input for EXTI11 external interrupt.\nOthers reserved
			EXTI11 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI external interrupt selection register
		EXTI_EXTICR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x6C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI12 GPIO port selection\nThese bits are written by software to select the source input for EXTI12 external interrupt.\nOthers reserved
			EXTI12 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI13 GPIO port selection\nThese bits are written by software to select the source input for EXTI13 external interrupt.\nOthers reserved
			EXTI13 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI14 GPIO port selection\nThese bits are written by software to select the source input for EXTI14 external interrupt.\nOthers reserved
			EXTI14 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI15 GPIO port selection\nThese bits are written by software to select the source input for EXTI15 external interrupt.\nOthers reserved
			EXTI15 {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI CPU wakeup with interrupt mask register 1
		EXTI_IMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x080, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line 19\nSetting/clearing this bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM19 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line 23\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM23 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line 25\nSetting/clearing each bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM25 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line 31\nSetting/clearing this bit unmasks/masks the CPU wakeup with interrupt, by an event on the corresponding line.
			IM31 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI CPU wakeup with event mask register
		EXTI_EMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x084, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line x (x = 15 to 0)\nSetting/clearing each bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line 19\nSetting/clearing this bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM19 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line 23\nSetting/clearing this bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM23 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line 25\nSetting/clearing this bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM25 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line 31\nSetting/clearing this bit unmasks/masks the CPU wakeup with event generation on the corresponding line.
			EM31 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI CPU wakeup with interrupt mask register 2
		EXTI_IMR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x090, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on line 34\nSetting/clearing the bit unmasks/masks the CPU wakeup with interrupt request from the line 34.
			IM34 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI CPU wakeup with event mask register 2
		EXTI_EMR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x094, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CPU wakeup with event generation mask on line 34\nSetting/clearing this bit unmasks/masks the CPU wakeup with event generation on the line 34.
			EM34 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief FLASH register block
	FLASH {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40022000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief FLASH access control register
		FLASH_ACR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x000, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Flash memory access latency\nThe value in this bitfield represents the number of CPU wait states when accessing the flash memory.\nOther: Reserved\nA new write into the bitfield becomes effective when it returns the same value upon read.
			LATENCY {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU Prefetch enable
			PRFTEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU Instruction cache enable
			ICEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU Instruction cache reset\nThis bit can be written only when the instruction cache is disabled.
			ICRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Main flash memory area empty\nThis bit indicates whether the first location of the Main flash memory area was read as erased or as programmed during OBL. It is not affected by the system reset. Software may need to change this bit value after a flash memor
			EMPTY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Debug access software enable\nSoftware may use this bit to enable/disable the debugger read access.
			DBG_SWEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH key register
		FLASH_KEYR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x008, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief FLASH key\nThe following values must be written consecutively to unlock the FLASH control register (FLASH_CR), thus enabling programming/erasing operations:\nKEY1: 0x4567 0123\nKEY2: 0xCDEF 89AB
			KEY {
				ec.Access : {W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH option key register
		FLASH_OPTKEYR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Option byte key\nThe following values must be written consecutively to unlock the flash memory option registers, enabling option byte programming/erasing operations:\nKEY1: 0x0819 2A3B\nKEY2: 0x4C5D 6E7F
			OPTKEY {
				ec.Access : {W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH status register
		FLASH_SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x010, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief End of operation\nSet by hardware when one or more flash memory operation (programming / erase) has been completed successfully.\nThis bit is set only if the end of operation interrupts are enabled (EOPIE=1).\nCleared by writing 1.
			EOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Operation error\nSet by hardware when a flash memory operation (program / erase) completes unsuccessfully.\nThis bit is set only if error interrupts are enabled (ERRIE=1).\nCleared by writing  1 .
			OPERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Programming error\nSet by hardware when a double-word address to be programmed contains a value different from '0xFFFF FFFF' before programming, except if the data to write is '0x0000 0000'.\nCleared by writing 1.
			PROGERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Write protection error\nSet by hardware when an address to be erased/programmed belongs to a write-protected part (by WRP, PCROP or RDP Level 1) of the flash memory.\nCleared by writing 1.
			WRPERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Programming alignment error\nSet by hardware when the data to program cannot be contained in the same double word (64-bit) flash memory in case of standard programming, or if there is a change of page during fast programming.\nCleared by writing 1.
			PGAERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Size error\nSet by hardware when the size of the access is a byte or half-word during a program or a fast program sequence. Only double word programming is allowed (consequently: word access).\nCleared by writing 1.
			SIZERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Programming sequence error\nSet by hardware when a write access to the flash memory is performed by the code while PG or FSTPG have not been set previously. Set also by hardware when PROGERR, SIZERR, PGAERR, WRPERR, MISSERR or FASTERR is set due to a previ
			PGSERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast programming data miss error\nIn Fast programming mode, 16 double words (128 bytes) must be sent to flash memory successively, and the new data must be sent to the logic control before the current data is fully programmed. MISSERR is set by hardware wh
			MISSERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast programming error\nSet by hardware when a fast programming sequence (activated by FSTPG) is interrupted due to an error (alignment, size, write protection or data miss). The corresponding status bit (PGAERR, SIZERR, WRPERR or MISSERR) is set at the sa
			FASTERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PCROP read error\nSet by hardware when an address to be read belongs to a read protected area of the flash memory (PCROP protection). An interrupt is generated if RDERRIE is set in FLASH_CR.\nCleared by writing 1.
			RDERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Option and Engineering bits loading validity error
			OPTVERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Busy\nThis flag indicates that a flash memory operation requested by FLASH control register (FLASH_CR) is in progress. This bit is set at the beginning of the flash memory operation, and cleared when the operation finishes or when an error occurs.
			BSY1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Programming or erase configuration busy.\nThis flag is set and reset by hardware.\nFor flash program operation, it is set when the first word is sent, and cleared after the second word is sent when the operation completes or ends with an error.\nFor flash er
			CFGBSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH control register
		FLASH_CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x014, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Flash memory programming enable
			PG {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Page erase enable
			PER {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mass erase\nWhen set, this bit triggers the mass erase, that is, all user pages.
			MER1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Page number selection\nThese bits select the page to erase:\n...\nNote: Values corresponding to addresses outside the Main memory are not allowed. See Table 6 and Table 7.
			PNB {
				ec.Access : {R|W}
				ec.Size : {size : {6, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Start erase operation\nThis bit triggers an erase operation when set.\nThis bit is possible to set only by software and to clear only by hardware. The hardware clears it when one of BSY1 and BSY2 flags in the FLASH_SR register transits to zero.
			STRT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Start of modification of option bytes\nThis bit triggers an options operation when set.\nThis bit is set only by software, and is cleared when the BSY1 bit is cleared in FLASH_SR.
			OPTSTRT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast programming enable
			FSTPG {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End-of-operation interrupt enable\nThis bit enables the interrupt generation upon setting the EOP flag in the FLASH_SR register.
			EOPIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupt enable\nThis bit enables the interrupt generation upon setting the OPERR flag in the FLASH_SR register.
			ERRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PCROP read error interrupt enable\nThis bit enables the interrupt generation upon setting the RDERR flag in the FLASH_SR register.
			RDERRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Option byte load launch\nWhen set, this bit triggers the load of option bytes into option registers. It is automatically cleared upon the completion of the load. The high state of the bit indicates pending option byte load.\nThe bit cannot be cleared by sof
			OBL_LAUNCH {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Securable memory area protection enable\nThis bit enables the protection on securable area, provided that a non-null securable memory area size (SEC_SIZE[4:0]) is defined in option bytes.\nThis bit is possible to set only by software and to clear only throu
			SEC_PROT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Options Lock\nThis bit is set only. When set, all bits concerning user option in FLASH_CR register and so option page are locked. This bit is cleared by hardware after detecting the unlock sequence. The LOCK bit must be cleared before doing the unlock sequ
			OPTLOCK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FLASH_CR Lock\nThis bit is set only. When set, the FLASH_CR register is locked. It is cleared by hardware after detecting the unlock sequence.\nIn case of an unsuccessful unlock operation, this bit remains set until the next system reset.
			LOCK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH option register
		FLASH_OPTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x020, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Read protection level\nOther: Level 1, memories read protection active
			RDP {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Brown out reset enable
			BOR_EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BOR threshold at rising V<sub>DD</sub> supply\nRising V<sub>DD</sub> crossings this threshold releases the reset signal.
			BORR_LEV {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BOR threshold at falling V<sub>DD</sub> supply\nFalling V<sub>DD</sub> crossings this threshold activates the reset signal.
			BORF_LEV {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief None
			NRST_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief None
			NRST_STDBY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief None
			NRST_SHDW {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief None
			IWDG_SW {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Independent watchdog counter freeze in Stop mode
			IWDG_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief None
			IWGD_STDBY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Window watchdog selection
			WWDG_SW {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE remapping enable/disable\nWhen cleared, the bit remaps the HSE clock source from PF0-OSC_IN/PF1-OSC_OUT pins to PC14-OSCX_IN/PC15-OSCX_OUT. Thus PC14-OSCX_IN/PC15-OSCX_OUT are shared by both LSE and HSE and the two clock sources cannot be use simultane
			HSE_NOT_REMAPPED {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SRAM parity check control enable/disable
			RAM_PARITY_CHECK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Multiple-bonding security\nThe bit allows enabling automatic I/O configuration to prevent conflicts on I/Os connected (bonded) onto the same pin.\nIf the software sets one of the I/Os connected to the same pin as active by configuring the SYSCFG_CFGR3 regis
			SECURE_MUXING_EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BOOT0 signal source selection\nThis option bit defines the source of the BOOT0 signal.
			NBOOT_SEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Boot configuration\nTogether with the BOOT0 pin or option bit nBOOT0 (depending on nBOOT_SEL option bit configuration), this bit selects boot mode from the Main flash memory, SRAM or the System memory. Refer to Section 3: Boot configuration.
			NBOOT1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief nBOOT0 option bit
			NBOOT0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NRST pin configuration
			NRST_MODE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal reset holder enable bit
			IRHEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH PCROP area A start address register
		FLASH_PCROP1ASR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x024, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief PCROP1A area start offset\nContains the offset of the first subpage of the PCROP1A area.\nNote: The number of effective bits depends on the size of the flash memory in the device.
			PCROP1A_STRT {
				ec.Access : {R|W}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH PCROP area A end address register
		FLASH_PCROP1AER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x028, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief PCROP1A area end offset\nContains the offset of the last subpage of the PCROP1A area.\nNote: The number of effective bits depends on the size of the flash memory in the device.
			PCROP1A_END {
				ec.Access : {R|W}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PCROP area erase upon RDP level regression\nThis bit determines whether the PCROP area (and the totality of the PCROP area boundary pages) is erased by the mass erase triggered by the RDP level regression from Level 1 to Level 0:\nThe software can only set 
			PCROP_RDP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH WRP area A address register
		FLASH_WRP1AR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x02C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief WRP area A start offset\nThis bitfield contains the offset of the first page of the WRP area A.\nNote: The number of effective bits depends on the size of the flash memory in the device.
			WRP1A_STRT {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WRP area A end offset\nThis bitfield contains the offset of the last page of the WRP area A.\nNote: The number of effective bits depends on the size of the flash memory in the device.
			WRP1A_END {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH WRP area B address register
		FLASH_WRP1BR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x030, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief WRP area B start offset\nThis bitfield contains the offset of the first page of the WRP area B.\nNote: The number of effective bits depends on the size of the flash memory in the device.
			WRP1B_STRT {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WRP area B end offset\nThis bitfield contains the offset of the last page of the WRP area B.\nNote: The number of effective bits depends on the size of the flash memory in the device.
			WRP1B_END {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH PCROP area B start address register
		FLASH_PCROP1BSR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x034, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief PCROP1B area start offset\nContains the offset of the first subpage of the PCROP1B area.\nNote: The number of effective bits depends on the size of the flash memory in the device.
			PCROP1B_STRT {
				ec.Access : {R|W}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH PCROP area B end address register
		FLASH_PCROP1BER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x038, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief PCROP1B area end offset\nContains the offset of the last subpage of the PCROP1B area.\nNote: The number of effective bits depends on the size of the flash memory in the device.
			PCROP1B_END {
				ec.Access : {R|W}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH security register
		FLASH_SECR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x080, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Securable memory area size\nContains the number of securable flash memory pages.\nNote: The number of effective bits depends on the size of the flash memory in the device.
			SEC_SIZE {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief used to force boot from user area\nIf the bit is set in association with RDP level 1, the debug capabilities are disabled, except in the case of a bad OBL (mismatch).
			BOOT_LOCK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief GPIOA address block description
	GPIOA {
		ec.Peripheral : {0}
		ec.Size : {size : {0x2C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50000000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		GPIOA_MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		GPIOA_OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed register
		GPIOA_OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down register
		GPIOA_PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		GPIOA_IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID0 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID8 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID9 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID10 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID11 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID12 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID13 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID14 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID15 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		GPIOA_ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset register
		GPIOA_BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock register
		GPIOA_LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] =  1  + LCKR[15:0]\nWR LCKR[16] =  0  + LCKR[15:0]\nWR LCKR[16] =  1  + LCKR[15:0]\nRD LCKR\nRD LCKR[16] =  1  (this read o
			LCKK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low register
		GPIOA_AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL0 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL1 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL2 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL3 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL4 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL5 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL6 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL7 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high register
		GPIOA_AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL8 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL9 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL10 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL11 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL12 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL13 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL14 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL15 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit reset register
		GPIOA_BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief GPIOB address block description
	GPIOB {
		ec.Peripheral : {0}
		ec.Size : {size : {0x2C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50000400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		GPIOB_MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		GPIOB_OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed register
		GPIOB_OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down register
		GPIOB_PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		GPIOB_IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID0 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID8 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID9 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID10 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID11 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID12 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID13 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID14 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID15 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		GPIOB_ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset register
		GPIOB_BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock register
		GPIOB_LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] =  1  + LCKR[15:0]\nWR LCKR[16] =  0  + LCKR[15:0]\nWR LCKR[16] =  1  + LCKR[15:0]\nRD LCKR\nRD LCKR[16] =  1  (this read o
			LCKK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low register
		GPIOB_AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL0 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL1 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL2 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL3 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL4 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL5 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL6 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL7 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high register
		GPIOB_AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL8 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL9 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL10 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL11 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL12 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL13 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL14 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL15 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit reset register
		GPIOB_BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief GPIOC address block description
	GPIOC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x2C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50000800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		GPIOC_MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		GPIOC_OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed register
		GPIOC_OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down register
		GPIOC_PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		GPIOC_IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID0 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID8 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID9 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID10 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID11 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID12 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID13 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID14 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID15 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		GPIOC_ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset register
		GPIOC_BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock register
		GPIOC_LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] =  1  + LCKR[15:0]\nWR LCKR[16] =  0  + LCKR[15:0]\nWR LCKR[16] =  1  + LCKR[15:0]\nRD LCKR\nRD LCKR[16] =  1  (this read o
			LCKK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low register
		GPIOC_AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL0 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL1 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL2 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL3 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL4 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL5 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL6 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL7 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high register
		GPIOC_AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL8 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL9 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL10 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL11 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL12 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL13 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL14 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL15 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit reset register
		GPIOC_BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief GPIOD address block description
	GPIOD {
		ec.Peripheral : {0}
		ec.Size : {size : {0x2C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50000C00, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		GPIOD_MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		GPIOD_OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed register
		GPIOD_OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down register
		GPIOD_PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		GPIOD_IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID0 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID8 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID9 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID10 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID11 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID12 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID13 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID14 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID15 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		GPIOD_ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset register
		GPIOD_BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock register
		GPIOD_LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] =  1  + LCKR[15:0]\nWR LCKR[16] =  0  + LCKR[15:0]\nWR LCKR[16] =  1  + LCKR[15:0]\nRD LCKR\nRD LCKR[16] =  1  (this read o
			LCKK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low register
		GPIOD_AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL0 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL1 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL2 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL3 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL4 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL5 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL6 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL7 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high register
		GPIOD_AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL8 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL9 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL10 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL11 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL12 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL13 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL14 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL15 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit reset register
		GPIOD_BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief GPIOF address block description
	GPIOF {
		ec.Peripheral : {0}
		ec.Size : {size : {0x2C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50001400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		GPIOF_MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to set the I/O to one of four operating modes.
			MODE15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		GPIOF_OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output type.
			OT15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed register
		GPIOF_OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration for I/O y\nThese bits are written by software to configure the I/O output speed.\nRefer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed..\nNote: The FT_c GPIOs cannot be se
			OSPEED15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down register
		GPIOF_PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD6 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD7 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD8 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD9 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD10 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD11 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD12 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD13 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD14 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration I/O y\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: On the same pin, this pull up/down must not be activated when a pull down/up is set through the PWR_PDCRx/PWR_PUCRx registers.
			PUPD15 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		GPIOF_IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID0 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID8 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID9 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID10 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID11 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID12 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID13 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID14 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x input data I/O y\nThese bits are read-only. They contain the input value of the corresponding I/O port.
			ID15 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		GPIOF_ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data I/O y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A, B, C, D, F).
			OD15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset register
		GPIOF_BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BS15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.\nNote: If both BSx and BRx are set, BSx has priority.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock register
		GPIOF_LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is  0.
			LCK15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] =  1  + LCKR[15:0]\nWR LCKR[16] =  0  + LCKR[15:0]\nWR LCKR[16] =  1  + LCKR[15:0]\nRD LCKR\nRD LCKR[16] =  1  (this read o
			LCKK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low register
		GPIOF_AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL0 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL1 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL2 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL3 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL4 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL5 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL6 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x pin y\nThese bits are written by software to configure alternate function I/Os
			AFSEL7 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high register
		GPIOF_AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL8 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL9 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL10 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL11 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL12 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL13 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL14 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x, I/O y\nThese bits are written by software to configure alternate function I/Os
			AFSEL15 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit reset register
		GPIOF_BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR0 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR8 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR9 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR10 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR11 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR12 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR13 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR14 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset I/O y\nThese bits are write-only. A read operation always returns 0x0000.
			BR15 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief IWDG address block description
	IWDG {
		ec.Peripheral : {0}
		ec.Size : {size : {0x14, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40003000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief IWDG key register
		IWDG_KR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Key value (write only, read 0x0000)\nThese bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0.\nWriting the key value 0x5555 to enable access to the IWDG_PR, I
			KEY {
				ec.Access : {W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief IWDG prescaler register
		IWDG_PR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler divider\nThese bits are write access protected see Section 22.3.4: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the IWDG status register (IWDG_SR) must be reset in 
			PR {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief IWDG reload register
		IWDG_RLR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Watchdog counter reload value\nThese bits are write access protected see Register access protection. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG key register (IWDG_
			RL {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief IWDG status register
		IWDG_SR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Watchdog prescaler value update\nThis bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the V<sub>DD</sub> voltage domain (takes up to five LSI c
			PVU {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Watchdog counter reload value update\nThis bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the V<sub>DD</sub> voltage domain (takes up to five 
			RVU {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Watchdog counter window value update\nThis bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the V<sub>DD</sub> voltage domain (takes up to five 
			WVU {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief IWDG window register
		IWDG_WINR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Watchdog counter window value\nThese bits are write access protected, see Section 22.3.4, they contain the high limit of the window value to be compared with the downcounter.\nTo prevent a reset, the downcounter must be reloaded when its value is lower than
			WIN {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief I2C address block description
	I2C1 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x2C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40005400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief I2C control register 1
		I2C_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral enable\nNote: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least three APB clock cycles.
			PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TX interrupt enable
			TXIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX interrupt enable
			RXIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address match interrupt enable (slave only)
			ADDRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge received interrupt enable
			NACKIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop detection interrupt enable
			STOPIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete interrupt enable\nNote: Any of these events generates an interrupt:\nNote: Transfer complete (TC)\nNote: Transfer complete reload (TCR)
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupts enable\nNote: Any of these errors generates an interrupt:\nNote: Arbitration loss (ARLO)\nNote: Bus error detection (BERR)\nNote: Overrun/underrun (OVR)\nNote: Timeout detection (TIMEOUT)\nNote: PEC error detection (PECERR)\nNote: Alert pin even
			ERRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Digital noise filter\nThese bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * t<sub>I2CCLK</sub>\n...\nNote: If the analog filter is enabled, the digital filter is a
			DNF {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog noise filter OFF\nNote: This bit can be programmed only when the I2C is disabled (PE = 0).
			ANFOFF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA transmission requests enable
			TXDMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA reception requests enable
			RXDMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave byte control\nThis bit is used to enable hardware byte control in slave mode.
			SBC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock stretching disable\nThis bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.\nNote: This bit can be programmed only when the I2C is disabled (PE = 0).
			NOSTRETCH {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from Stop mode enable\nNote: If the wake-up from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.\nNote: WUPEN can be set only when DNF = 0000.
			WUPEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief General call enable
			GCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus host address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			SMBHEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus device default address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			SMBDEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus alert enable\nNote: When ALERTEN = 0, the SMBA pin can be used as a standard GPIO.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			ALERTEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			PECEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C control register 2
		I2C_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Slave address (master mode)\nIn 7-bit addressing mode (ADD10 = 0):\nSADD[7:1] must be written with the 7-bit slave address to be sent. Bits SADD[9], SADD[8] and SADD[0] are don't care.\nIn 10-bit addressing mode (ADD10 = 1):\nSADD[9:0] must be written with th
			SADD {
				ec.Access : {R|W}
				ec.Size : {size : {10, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer direction (master mode)\nNote: Changing this bit when the START bit is set is not allowed.
			RD_WRN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 10-bit addressing mode (master mode)\nNote: Changing this bit when the START bit is set is not allowed.
			ADD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 10-bit address header only read direction (master receiver mode)\nNote: Changing this bit when the START bit is set is not allowed.
			HEAD10R {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Start generation\nThis bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0.\nIf the I2C is alread
			START {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop generation (master mode)\nThe bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.\nIn master mode:\nNote: Writing 0 to this bit has no effect.
			STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NACK generation (slave mode)\nThe bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE = 0.\nNote: Writing 0 to this bit has no effect.\nNote: This bit is used only in slave
			NACK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of bytes\nThe number of bytes to be transmitted/received is programmed there. This field is don t care in slave mode with SBC = 0.\nNote: Changing these bits when the START bit is set is not allowed.
			NBYTES {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NBYTES reload mode\nThis bit is set and cleared by software.
			RELOAD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic end mode (master mode)\nThis bit is set and cleared by software.\nNote: This bit has no effect in slave mode or when the RELOAD bit is set.
			AUTOEND {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Packet error checking byte\nThis bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE = 0.\nNote: Writing 0 to this bit has no effect.\nNote: This bit has no eff
			PECBYTE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C own address 1 register
		I2C_OAR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Interface own slave address\n7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. Bits OA1[9], OA1[8] and OA1[0] are don't care.\n10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.\nNote: These bits can be written only w
			OA1 {
				ec.Access : {R|W}
				ec.Size : {size : {10, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own address 1 10-bit mode\nNote: This bit can be written only when OA1EN = 0.
			OA1MODE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own address 1 enable
			OA1EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C own address 2 register
		I2C_OAR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Interface address\n7-bit addressing mode: 7-bit address\nNote: These bits can be written only when OA2EN = 0.
			OA2 {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own address 2 masks
			OA2MSK {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own address 2 enable
			OA2EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C timing register
		I2C_TIMINGR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SCL low period (master mode)\nThis field is used to generate the SCL low period in master mode.\nt<sub>SCLL </sub>= (SCLL + 1) x t<sub>PRESC</sub>\nNote: SCLL is also used to generate t<sub>BUF </sub>and t<sub>SU:STA </sub>timings.
			SCLL {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SCL high period (master mode)\nThis field is used to generate the SCL high period in master mode.\nt<sub>SCLH </sub>= (SCLH + 1) x t<sub>PRESC</sub>\nNote: SCLH is also used to generate t<sub>SU:STO </sub>and t<sub>HD:STA </sub>timing.
			SCLH {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data hold time\nThis field is used to generate the delay t<sub>SDADEL </sub>between SCL falling edge and SDA edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SDADEL</sub>.\nt<sub>SDADEL</sub>= SDADEL x t<sub>
			SDADEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data setup time\nThis field is used to generate a delay t<sub>SCLDEL</sub> = (SCLDEL + 1) x t<sub>PRESC</sub> between SDA edge and SCL rising edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SCLDEL</sub>.\nNo
			SCLDEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timing prescaler\nThis field is used to prescale I2CCLK to generate the clock period t<sub>PRESC </sub>used for data setup and hold counters (refer to I2C timings), and for SCL high and low level counters (refer to I2C master initialization).\nt<sub>PRESC <
			PRESC {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C timeout register
		I2C_TIMEOUTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Bus timeout A\nThis field is used to configure:\nThe SCL low timeout condition t<sub>TIMEOUT</sub> when TIDLE = 0\nt<sub>TIMEOUT</sub>= (TIMEOUTA + 1) x 2048 x t<sub>I2CCLK</sub>\nThe bus idle condition (both SCL and SDA high) when TIDLE = 1\nt<sub>IDLE</sub>=
			TIMEOUTA {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle clock timeout detection\nNote: This bit can be written only when TIMOUTEN = 0.
			TIDLE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock timeout enable
			TIMOUTEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus timeout B\nThis field is used to configure the cumulative clock extension timeout:\nMaster mode: the master cumulative clock low extend time (t<sub>LOW:MEXT</sub>) is detected\nSlave mode: the slave cumulative clock low extend time (t<sub>LOW:SEXT</sub>)
			TIMEOUTB {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Extended clock timeout enable
			TEXTEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C interrupt and status register
		I2C_ISR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Transmit data register empty (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register.\nThis bit can be written to 1 by software in order to flush the tr
			TXE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit interrupt status (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR regist
			TXIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data register not empty (receivers)\nThis bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read.\nNote: This bit is cleared by hardware when PE = 0.
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address matched (slave mode)\nThis bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit.\nNote: This bit is cleared by hardware when PE = 0.
			ADDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge received flag\nThis flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit.\nNote: This bit is cleared by hardware when PE = 0.
			NACKF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop detection flag\nThis flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer:\nas a master, provided that the STOP condition is generated by the peripheral.\nas a slave, provided that the peri
			STOPF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete (master mode)\nThis flag is set by hardware when RELOAD = 0, AUTOEND = 0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set.\nNote: This bit is cleared by hardware when PE = 0.
			TC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete reload\nThis flag is set by hardware when RELOAD = 1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value.\nNote: This bit is cleared by hardware when PE = 0.\nNote: This flag is only f
			TCR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus error\nThis flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting the BERRCF bit
			BERR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Arbitration lost\nThis flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit.\nNote: This bit is cleared by hardware when PE = 0.
			ARLO {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun/underrun (slave mode)\nThis flag is set by hardware in slave mode with NOSTRETCH = 1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.\nNote: This bit is cleared by hardware when PE = 0.
			OVR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC error in reception\nThis flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit.\nNote: This bit is clear
			PECERR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timeout or t<sub>LOW</sub> detection flag\nThis flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit.\nNote: This bit is cleared by hardware when PE = 0.\nNote: If the SMBus feature
			TIMEOUT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus alert\nThis flag is set by hardware when SMBHEN = 1 (SMBus host configuration), ALERTEN = 1 and an SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit.\nNote: This bit is cleared by hardware when
			ALERT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus busy\nThis flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected, and cleared by hardware when a STOP condition is detected, or when PE = 0.
			BUSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer direction (slave mode)\nThis flag is updated when an address match event occurs (ADDR = 1).
			DIR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address match code (slave mode)\nThese bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the two MSBs of the address.
			ADDCODE {
				ec.Access : {R}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C interrupt clear register
		I2C_ICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Address matched flag clear\nWriting 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
			ADDRCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge flag clear\nWriting 1 to this bit clears the NACKF flag in I2C_ISR register.
			NACKCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief STOP detection flag clear\nWriting 1 to this bit clears the STOPF flag in the I2C_ISR register.
			STOPCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus error flag clear\nWriting 1 to this bit clears the BERRF flag in the I2C_ISR register.
			BERRCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Arbitration lost flag clear\nWriting 1 to this bit clears the ARLO flag in the I2C_ISR register.
			ARLOCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun/underrun flag clear\nWriting 1 to this bit clears the OVR flag in the I2C_ISR register.
			OVRCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC error flag clear\nWriting 1 to this bit clears the PECERR flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			PECCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timeout detection flag clear\nWriting 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			TIMOUTCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alert flag clear\nNote: Writing 1 to this bit clears the ALERT flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			ALERTCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C PEC register
		I2C_PECR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Packet error checking register\nThis field contains the internal PEC when PECEN=1.\nThe PEC is cleared by hardware when PE = 0.
			PEC {
				ec.Access : {R}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C receive data register
		I2C_RXDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 8-bit receive data\nData byte received from the I<sup>2</sup>C bus
			RXDATA {
				ec.Access : {R}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C transmit data register
		I2C_TXDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 8-bit transmit data\nData byte to be transmitted to the I<sup>2</sup>C bus\nNote: These bits can be written only when TXE = 1.
			TXDATA {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief I2C address block description
	I2C2 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x2C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40005800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief I2C control register 1
		I2C_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral enable\nNote: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least three APB clock cycles.
			PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TX interrupt enable
			TXIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX interrupt enable
			RXIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address match interrupt enable (slave only)
			ADDRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge received interrupt enable
			NACKIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop detection interrupt enable
			STOPIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete interrupt enable\nNote: Any of these events generates an interrupt:\nNote: Transfer complete (TC)\nNote: Transfer complete reload (TCR)
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupts enable\nNote: Any of these errors generates an interrupt:\nNote: Arbitration loss (ARLO)\nNote: Bus error detection (BERR)\nNote: Overrun/underrun (OVR)\nNote: Timeout detection (TIMEOUT)\nNote: PEC error detection (PECERR)\nNote: Alert pin even
			ERRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Digital noise filter\nThese bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * t<sub>I2CCLK</sub>\n...\nNote: If the analog filter is enabled, the digital filter is a
			DNF {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog noise filter OFF\nNote: This bit can be programmed only when the I2C is disabled (PE = 0).
			ANFOFF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA transmission requests enable
			TXDMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA reception requests enable
			RXDMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave byte control\nThis bit is used to enable hardware byte control in slave mode.
			SBC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock stretching disable\nThis bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.\nNote: This bit can be programmed only when the I2C is disabled (PE = 0).
			NOSTRETCH {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from Stop mode enable\nNote: If the wake-up from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.\nNote: WUPEN can be set only when DNF = 0000.
			WUPEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief General call enable
			GCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus host address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			SMBHEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus device default address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			SMBDEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus alert enable\nNote: When ALERTEN = 0, the SMBA pin can be used as a standard GPIO.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			ALERTEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			PECEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C control register 2
		I2C_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Slave address (master mode)\nIn 7-bit addressing mode (ADD10 = 0):\nSADD[7:1] must be written with the 7-bit slave address to be sent. Bits SADD[9], SADD[8] and SADD[0] are don't care.\nIn 10-bit addressing mode (ADD10 = 1):\nSADD[9:0] must be written with th
			SADD {
				ec.Access : {R|W}
				ec.Size : {size : {10, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer direction (master mode)\nNote: Changing this bit when the START bit is set is not allowed.
			RD_WRN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 10-bit addressing mode (master mode)\nNote: Changing this bit when the START bit is set is not allowed.
			ADD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 10-bit address header only read direction (master receiver mode)\nNote: Changing this bit when the START bit is set is not allowed.
			HEAD10R {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Start generation\nThis bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0.\nIf the I2C is alread
			START {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop generation (master mode)\nThe bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.\nIn master mode:\nNote: Writing 0 to this bit has no effect.
			STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NACK generation (slave mode)\nThe bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE = 0.\nNote: Writing 0 to this bit has no effect.\nNote: This bit is used only in slave
			NACK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of bytes\nThe number of bytes to be transmitted/received is programmed there. This field is don t care in slave mode with SBC = 0.\nNote: Changing these bits when the START bit is set is not allowed.
			NBYTES {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NBYTES reload mode\nThis bit is set and cleared by software.
			RELOAD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic end mode (master mode)\nThis bit is set and cleared by software.\nNote: This bit has no effect in slave mode or when the RELOAD bit is set.
			AUTOEND {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Packet error checking byte\nThis bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE = 0.\nNote: Writing 0 to this bit has no effect.\nNote: This bit has no eff
			PECBYTE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C own address 1 register
		I2C_OAR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Interface own slave address\n7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. Bits OA1[9], OA1[8] and OA1[0] are don't care.\n10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.\nNote: These bits can be written only w
			OA1 {
				ec.Access : {R|W}
				ec.Size : {size : {10, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own address 1 10-bit mode\nNote: This bit can be written only when OA1EN = 0.
			OA1MODE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own address 1 enable
			OA1EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C own address 2 register
		I2C_OAR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Interface address\n7-bit addressing mode: 7-bit address\nNote: These bits can be written only when OA2EN = 0.
			OA2 {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own address 2 masks
			OA2MSK {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own address 2 enable
			OA2EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C timing register
		I2C_TIMINGR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SCL low period (master mode)\nThis field is used to generate the SCL low period in master mode.\nt<sub>SCLL </sub>= (SCLL + 1) x t<sub>PRESC</sub>\nNote: SCLL is also used to generate t<sub>BUF </sub>and t<sub>SU:STA </sub>timings.
			SCLL {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SCL high period (master mode)\nThis field is used to generate the SCL high period in master mode.\nt<sub>SCLH </sub>= (SCLH + 1) x t<sub>PRESC</sub>\nNote: SCLH is also used to generate t<sub>SU:STO </sub>and t<sub>HD:STA </sub>timing.
			SCLH {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data hold time\nThis field is used to generate the delay t<sub>SDADEL </sub>between SCL falling edge and SDA edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SDADEL</sub>.\nt<sub>SDADEL</sub>= SDADEL x t<sub>
			SDADEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data setup time\nThis field is used to generate a delay t<sub>SCLDEL</sub> = (SCLDEL + 1) x t<sub>PRESC</sub> between SDA edge and SCL rising edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SCLDEL</sub>.\nNo
			SCLDEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timing prescaler\nThis field is used to prescale I2CCLK to generate the clock period t<sub>PRESC </sub>used for data setup and hold counters (refer to I2C timings), and for SCL high and low level counters (refer to I2C master initialization).\nt<sub>PRESC <
			PRESC {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C timeout register
		I2C_TIMEOUTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Bus timeout A\nThis field is used to configure:\nThe SCL low timeout condition t<sub>TIMEOUT</sub> when TIDLE = 0\nt<sub>TIMEOUT</sub>= (TIMEOUTA + 1) x 2048 x t<sub>I2CCLK</sub>\nThe bus idle condition (both SCL and SDA high) when TIDLE = 1\nt<sub>IDLE</sub>=
			TIMEOUTA {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle clock timeout detection\nNote: This bit can be written only when TIMOUTEN = 0.
			TIDLE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock timeout enable
			TIMOUTEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus timeout B\nThis field is used to configure the cumulative clock extension timeout:\nMaster mode: the master cumulative clock low extend time (t<sub>LOW:MEXT</sub>) is detected\nSlave mode: the slave cumulative clock low extend time (t<sub>LOW:SEXT</sub>)
			TIMEOUTB {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Extended clock timeout enable
			TEXTEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C interrupt and status register
		I2C_ISR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Transmit data register empty (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register.\nThis bit can be written to 1 by software in order to flush the tr
			TXE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit interrupt status (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR regist
			TXIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data register not empty (receivers)\nThis bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read.\nNote: This bit is cleared by hardware when PE = 0.
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address matched (slave mode)\nThis bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit.\nNote: This bit is cleared by hardware when PE = 0.
			ADDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge received flag\nThis flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit.\nNote: This bit is cleared by hardware when PE = 0.
			NACKF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop detection flag\nThis flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer:\nas a master, provided that the STOP condition is generated by the peripheral.\nas a slave, provided that the peri
			STOPF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete (master mode)\nThis flag is set by hardware when RELOAD = 0, AUTOEND = 0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set.\nNote: This bit is cleared by hardware when PE = 0.
			TC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer complete reload\nThis flag is set by hardware when RELOAD = 1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value.\nNote: This bit is cleared by hardware when PE = 0.\nNote: This flag is only f
			TCR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus error\nThis flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting the BERRCF bit
			BERR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Arbitration lost\nThis flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit.\nNote: This bit is cleared by hardware when PE = 0.
			ARLO {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun/underrun (slave mode)\nThis flag is set by hardware in slave mode with NOSTRETCH = 1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.\nNote: This bit is cleared by hardware when PE = 0.
			OVR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC error in reception\nThis flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit.\nNote: This bit is clear
			PECERR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timeout or t<sub>LOW</sub> detection flag\nThis flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit.\nNote: This bit is cleared by hardware when PE = 0.\nNote: If the SMBus feature
			TIMEOUT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus alert\nThis flag is set by hardware when SMBHEN = 1 (SMBus host configuration), ALERTEN = 1 and an SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit.\nNote: This bit is cleared by hardware when
			ALERT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus busy\nThis flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected, and cleared by hardware when a STOP condition is detected, or when PE = 0.
			BUSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer direction (slave mode)\nThis flag is updated when an address match event occurs (ADDR = 1).
			DIR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address match code (slave mode)\nThese bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the two MSBs of the address.
			ADDCODE {
				ec.Access : {R}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C interrupt clear register
		I2C_ICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Address matched flag clear\nWriting 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
			ADDRCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge flag clear\nWriting 1 to this bit clears the NACKF flag in I2C_ISR register.
			NACKCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief STOP detection flag clear\nWriting 1 to this bit clears the STOPF flag in the I2C_ISR register.
			STOPCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus error flag clear\nWriting 1 to this bit clears the BERRF flag in the I2C_ISR register.
			BERRCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Arbitration lost flag clear\nWriting 1 to this bit clears the ARLO flag in the I2C_ISR register.
			ARLOCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun/underrun flag clear\nWriting 1 to this bit clears the OVR flag in the I2C_ISR register.
			OVRCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC error flag clear\nWriting 1 to this bit clears the PECERR flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			PECCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timeout detection flag clear\nWriting 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			TIMOUTCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alert flag clear\nNote: Writing 1 to this bit clears the ALERT flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 25.3.
			ALERTCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C PEC register
		I2C_PECR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Packet error checking register\nThis field contains the internal PEC when PECEN=1.\nThe PEC is cleared by hardware when PE = 0.
			PEC {
				ec.Access : {R}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C receive data register
		I2C_RXDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 8-bit receive data\nData byte received from the I<sup>2</sup>C bus
			RXDATA {
				ec.Access : {R}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I2C transmit data register
		I2C_TXDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 8-bit transmit data\nData byte to be transmitted to the I<sup>2</sup>C bus\nNote: These bits can be written only when TXE = 1.
			TXDATA {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief PWR address block description
	PWR {
		ec.Peripheral : {0}
		ec.Size : {size : {0x80, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40007000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief PWR control register 1
		PWR_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Low-power mode selection\nThese bits select the low-power mode entered when CPU enters deepsleep mode.\n1XX: Shutdown mode
			LPMS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory powered down during Stop mode\nThis bit determines whether the Flash memory is put in power-down mode or remains in idle mode when the device enters Stop mode.
			FPD_STOP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory powered down during Sleep mode\nThis bit determines whether the Flash memory is put in power-down mode or remains in idle mode when the device enters Sleep mode.
			FPD_SLP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR control register 1
		PWR_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief supply voltage monitoring
			PVM_VDDIO2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR control register 3
		PWR_CR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Enable WKUP1 wakeup pin\nWhen this bit is set, the WKUP1 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured via the WP1 bit of the PWR_CR4 register.
			EWUP1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable WKUP2 wakeup pin\nWhen this bit is set, the WKUP2 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured via the WP2 bit of the PWR_CR4 register.
			EWUP2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable WKUP3 wakeup pin\nWhen this bit is set, the WKUP3 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured via the WP3 bit of the PWR_CR4 register.
			EWUP3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable WKUP4 wakeup pin\nWhen this bit is set, the WKUP4 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured via the WP4 bit in the PWR_CR4 register.
			EWUP4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable WKUP5 wakeup pin\nWhen this bit is set, the WKUP5 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured through WP5 bit in the PWR_CR4 register.
			EWUP5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable WKUP6 wakeup pin\nWhen this bit is set, the WKUP6 external wakeup pin is enabled and triggers a wakeup event when a rising or a falling edge occurs. The active edge is configured through WP6 bit in the PWR_CR4 register.
			EWUP6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Apply pull-up and pull-down configuration\nThis bit determines whether the I/O pull-up and pull-down configurations defined in the PWR_PUCRx and PWR_PDCRx registers are applied.
			APC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable internal wakeup line\nWhen set, a rising edge on the internal wakeup line triggers a wakeup event.
			EIWUL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR control register 4
		PWR_CR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief WKUP1 wakeup pin polarity\nWKUP1 external wakeup signal polarity (level or edge) to generate wakeup condition:
			WP1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WKUP2 wakeup pin polarity\nWKUP2 external wakeup signal polarity (level or edge) to generate wakeup condition:
			WP2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WKUP3 wakeup pin polarity\nWKUP3 external wakeup signal polarity (level or edge) to generate wakeup condition:
			WP3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WKUP4 wakeup pin polarity\nWKUP4 external wakeup signal polarity (level or edge) to generate wakeup condition:
			WP4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WKUP5 wakeup pin polarity\nWKUP5 external wakeup signal polarity (level or edge) to generate wakeup condition:
			WP5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WKUP6 wakeup pin polarity\nWKUP6 external wakeup signal polarity (level or edge) to generate wakeup condition:
			WP6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR status register 1
		PWR_SR1 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Wakeup flag 1\nThis bit is set when a wakeup condition is detected on WKUP1 wakeup pin. It is cleared by setting the CWUF1 bit of the PWR_SCR register.
			WUF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 2\nThis bit is set when a wakeup condition is detected on WKUP2 wakeup pin. It is cleared by setting the CWUF2 bit of the PWR_SCR register.
			WUF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 3\nThis bit is set when a wakeup condition is detected on WKUP3 wakeup pin. It is cleared by setting the CWUF3 bit of the PWR_SCR register.
			WUF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 4\nThis bit is set when a wakeup condition is detected on WKUP4 wakeup pin. It is cleared by setting the CWUF4 bit of the PWR_SCR register.
			WUF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 5\nThis bit is set when a wakeup condition is detected on WKUP5 wakeup pin. It is cleared by setting the CWUF5 bit of the PWR_SCR register.
			WUF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 6\nThis bit is set when a wakeup condition is detected on WKUP6 wakeup pin. It is cleared by setting the CWUF6 bit of the PWR_SCR register.
			WUF6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Standby flag\nThis bit is set by hardware when the device enters Standby mode and is cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset.
			SBF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag internal\nThis bit is set when a wakeup condition is detected on the internal wakeup line. It is cleared when all internal wakeup sources are cleared.
			WUFI {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR status register 2
		PWR_SR2 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Flash ready flag\nThis bit is set by hardware to indicate when the Flash memory is ready to be accessed after wakeup from power-down. To place the Flash memory in power-down, set either FPD_SLP or FPD_STP bit.\nNote: If the system boots from SRAM, the user 
			FLASH_RDY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief V<sub>DDIO2</sub> supply voltage monitoring output flag\nThis flag indicates the readiness of the V<sub>DDIO2</sub> supply voltage (excess of 1.2 V).\nThe flag is cleared when the PVM of V<sub>DDIO2</sub> is disabled (PVM_VDDIO2[0] = 0).\nNote: Only applicab
			PVM_VDDIO2_OUT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR status clear register
		PWR_SCR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clear wakeup flag 1\nSetting this bit clears the WUF1 flag in the PWR_SR1 register.
			CWUF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 2\nSetting this bit clears the WUF2 flag in the PWR_SR1 register.
			CWUF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 3\nSetting this bit clears the WUF3 flag in the PWR_SR1 register.
			CWUF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 4\nSetting this bit clears the WUF4 flag in the PWR_SR1 register.
			CWUF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 5\nSetting this bit clears the WUF5 flag in the PWR_SR1 register.
			CWUF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 6\nSetting this bit clears the WUF6 flag in the PWR_SR1 register.
			CWUF6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear standby flag\nSetting this bit clears the SBF flag in the PWR_SR1 register.
			CSBF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port A pull-up control register
		PWR_PUCRA {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PA[i] I/O.\nNote: For the same pin, this pull-up device must not be activated when a pull-down dev
			PU15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port A pull-down control register
		PWR_PDCRA {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PA[i] I/O.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device is set through the GPIOx_PUPDR
			PD15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port B pull-up control register
		PWR_PUCRB {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PB[i] I/O.\nOn STM32C011xx, only PU7 and PU6 are available.\nNote: For the same pin, this pull-up d
			PU15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port B pull-down control register
		PWR_PDCRB {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PB[i] I/O.\nOn STM32C011xx, only PD7 and PD6 are available.\nNote: For the same pin, this pull-down device must not be activated when
			PD15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port C pull-up control register
		PWR_PUCRC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PC[i] I/O.\nOn STM32C011xx, only PU15 and PU14 are available. On STM32C031xx, only PU15 to PU13, P
			PU15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port C pull-down control register
		PWR_PDCRC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PC[i] I/O.\nOn STM32C011xx, only PD15 and PD14 are available. On STM32C031xx, only PD15 to PD13, PD7, and PD6 are available.\nNote: F
			PD15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port D pull-up control register
		PWR_PUCRD {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port D pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PU3 to PU0 are available.\nNote: For
			PU0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PU3 to PU0 are available.\nNote: For
			PU1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PU3 to PU0 are available.\nNote: For
			PU2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PU3 to PU0 are available.\nNote: For
			PU3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PU3 to PU0 are available.\nNote: For
			PU4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PU3 to PU0 are available.\nNote: For
			PU5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PU3 to PU0 are available.\nNote: For
			PU6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.\nOnly available on STM32C071xx.\nNote: For the same pin, this pull-up device must not be
			PU8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PD[i] I/O.\nOnly available on STM32C071xx.\nNote: For the same pin, this pull-up device must not be
			PU9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port D pull-down control register
		PWR_PDCRD {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port D pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PD3 to PD0 are available.\nNote: For the same pin, this pull-down devi
			PD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PD3 to PD0 are available.\nNote: For the same pin, this pull-down devi
			PD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PD3 to PD0 are available.\nNote: For the same pin, this pull-down devi
			PD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PD3 to PD0 are available.\nNote: For the same pin, this pull-down devi
			PD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PD3 to PD0 are available.\nNote: For the same pin, this pull-down devi
			PD4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PD3 to PD0 are available.\nNote: For the same pin, this pull-down devi
			PD5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.\nNot available on STM32C011xx. On STM32C031xx, only PD3 to PD0 are available.\nNote: For the same pin, this pull-down devi
			PD6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.\nOnly available on STM32C071xx.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device
			PD8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PD[i] I/O.\nOnly available on STM32C071xx.\nNote: For the same pin, this pull-down device must not be activated when a pull-up device
			PD9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port F pull-up control register
		PWR_PUCRF {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port F pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PF[i] I/O.\nOn STM32C011xx, only PU2 is available. On STM32C031xx, only PU2 to PU0 are available.\n
			PU0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PF[i] I/O.\nOn STM32C011xx, only PU2 is available. On STM32C031xx, only PU2 to PU0 are available.\n
			PU1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PF[i] I/O.\nOn STM32C011xx, only PU2 is available. On STM32C031xx, only PU2 to PU0 are available.\n
			PU2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit i\nSetting PUi bit while the corresponding PDi bit is zero and the APC bit of the PWR_CR3 register is set activates a pull-up device on the PF[i] I/O.\nOn STM32C011xx, only PU2 is available. On STM32C031xx, only PU2 to PU0 are available.\n
			PU3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR Port F pull-down control register
		PWR_PDCRF {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port F pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PF[i] I/O.\nOn STM32C011xx, only PD2 is available. On STM32C031xx, only PD2 to PD0 are available.\nNote: For the same pin, this pull-
			PD0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PF[i] I/O.\nOn STM32C011xx, only PD2 is available. On STM32C031xx, only PD2 to PD0 are available.\nNote: For the same pin, this pull-
			PD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PF[i] I/O.\nOn STM32C011xx, only PD2 is available. On STM32C031xx, only PD2 to PD0 are available.\nNote: For the same pin, this pull-
			PD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit i\nSetting PDi bit while the APC bit of the PWR_CR3 register is set activates a pull-down device on the PF[i] I/O.\nOn STM32C011xx, only PD2 is available. On STM32C031xx, only PD2 to PD0 are available.\nNote: For the same pin, this pull-
			PD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR backup 0 register
		PWR_BKP0R {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x70, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Backup bitfield\nThis bitfield retains information when the device is in Standby.
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR backup 1 register
		PWR_BKP1R {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x74, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Backup bitfield\nThis bitfield retains information when the device is in Standby.
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR backup 2 register
		PWR_BKP2R {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x78, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Backup bitfield\nThis bitfield retains information when the device is in Standby.
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PWR backup 3 register
		PWR_BKP3R {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x7C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Backup bitfield\nThis bitfield retains information when the device is in Standby.
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief RCC address block description
	RCC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x64, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40021000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief RCC clock control register
		RCC_CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clock division factor for system clock\nSet and cleared by software. SYSCLK is result of the division by:\nNote: This bitfield is only available on STM32C071xx.
			SYSDIV {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI48 kernel clock division factor\nThis bitfield controlled by software sets the division factor of the kernel clock divider to produce HSIKER clock:
			HSIKERDIV {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI48 clock enable\nSet and cleared by software and hardware, with hardware taking priority.\nKept low by hardware as long as the device is in a low-power mode.\nKept high by hardware as long as the system is clocked with a clock derived from HSI48. This inc
			HSION {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI48 always-enable for peripheral kernels.\nSet and cleared by software.\nSetting the bit activates the HSI48 oscillator in Run and Stop modes, regardless of the HSION bit state. The HSI48 clock can only feed USART1, USART2, and I2C1 peripherals configured
			HSIKERON {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI48 clock ready flag\nSet by hardware when the HSI48 oscillator is enabled through HSION and ready to use (stable).\nNote: Upon clearing HSION, HSIRDY goes low after six HSI48 clock cycles.
			HSIRDY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI48 clock division factor\nThis bitfield controlled by software sets the division factor of the HSI48 clock divider to produce HSISYS clock:
			HSIDIV {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE clock enable\nSet and cleared by software.\nCleared by hardware to stop the HSE oscillator when entering Stop, or Standby, or Shutdown mode. This bit cannot be cleared if the HSE oscillator is used directly or indirectly as the system clock.
			HSEON {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE clock ready flag\nSet by hardware to indicate that the HSE oscillator is stable and ready for use.\nNote: Upon clearing HSEON, HSERDY goes low after six HSE clock cycles.
			HSERDY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE crystal oscillator bypass\nSet and cleared by software.\nWhen the bit is set, the internal HSE oscillator is bypassed for use of an external clock. The external clock must then be enabled with the HSEON bit set. Write access to the bit is only effective
			HSEBYP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock security system enable\nSet by software to enable the clock security system. When the bit is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. The bit is clea
			CSSON {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSIUSB48 clock enable\nSet and cleared by software and hardware, with hardware taking priority. Kept low by hardware as long as the device is in a low-power mode. Kept high by hardware as long as the system is clocked from HSIUSB48.\nNote: Only applicable o
			HSIUSB48ON {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSIUSB48 clock ready flag\nSet by hardware when the HSIUSB48 oscillator is enabled through HSIUSB48ON and ready to use (stable).\nNote: Only applicable on STM32C071xx, reserved on other devices.
			HSIUSB48RDY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC internal clock source calibration register
		RCC_ICSCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief HSI48 clock calibration\nThis bitfield directly acts on the HSI48 clock frequency. Its value is a sum of an internal factory-programmed number and the value of the HSITRIM[6:0] bitfield. In the factory, the internal number is set to calibrate the HSI48 clo
			HSICAL {
				ec.Access : {R}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI48 clock trimming\nThe value of this bitfield contributes to the HSICAL[7:0] bitfield value.\nIt allows HSI48 clock frequency user trimming.\nThe HSI48 frequency accuracy as stated in the device datasheet applies when this bitfield is left at its reset va
			HSITRIM {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC clock configuration register
		RCC_CFGR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief System clock switch\nThis bitfield is controlled by software and hardware. The bitfield selects the clock for SYSCLK as follows:\nOthers: Reserved\nThe setting is forced by hardware to 000 (HSISYS selected) when the MCU exits Stop, or Standby, or Shutdown mo
			SW {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief System clock switch status\nThis bitfield is controlled by hardware to indicate the clock source used as system clock:\nOthers: Reserved
			SWS {
				ec.Access : {R}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief AHB prescaler\nThis bitfield is controlled by software. To produce HCLK clock, it sets the division factor of SYSCLK clock as follows:\n0xxx: 1
			HPRE {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief APB prescaler\nThis bitfield is controlled by software. To produce PCLK clock, it sets the division factor of HCLK clock as follows:\n0xx: 1
			PPRE {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Microcontroller clock output 2 clock selector\nThis bitfield is controlled by software. It sets the clock selector for MCO2 output as follows:\nOther: reserved, must not be used\nNote: This clock output may have some truncated cycles at startup or during MCO
			MCO2SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Microcontroller clock output 2 prescaler\nThis bitfield is controlled by software. It sets the division factor of the clock sent to the MCO2 output as follows:\n...\nOther: Reserved\nIt is highly recommended to set this field before the MCO2 output is enabled
			MCO2PRE {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Microcontroller clock output clock selector\nThis bitfield is controlled by software. It sets the clock selector for MCO output as follows:\nOther: reserved, must not be used\nNote: This clock output may have some truncated cycles at startup or during MCO cl
			MCOSEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Microcontroller clock output prescaler\nThis bitfield is controlled by software. It sets the division factor of the clock sent to the MCO output as follows:\n...\nOther: Reserved\nIt is highly recommended to set this field before the MCO output is enabled.\nNo
			MCOPRE {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC clock recovery RC register
		RCC_CRRCR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief HSIUSB48 clock calibration\nThese bits are initialized at startup with the factory-programmed HSIUSB48 calibration trim\nvalue.
			HSIUSB48CAL {
				ec.Access : {R}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC clock interrupt enable register
		RCC_CIER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSI ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization:
			LSIRDYIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization:
			LSERDYIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSIUSB48 ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the HSIUSB48 oscillator stabilization:\nNote: Only applicable on STM32C071xx, reserved on other devices.
			HSIUSB48RDYIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI48 ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the HSI48 oscillator stabilization:
			HSIRDYIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization:
			HSERDYIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC clock interrupt flag register
		RCC_CIFR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSI ready interrupt flag\nThis flag indicates a pending interrupt upon LSE clock getting ready.\nSet by hardware when the LSI clock becomes stable and LSIRDYDIE is set.\nCleared by software setting the LSIRDYC bit.
			LSIRDYF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE ready interrupt flag\nThis flag indicates a pending interrupt upon LSE clock getting ready.\nSet by hardware when the LSE clock becomes stable and LSERDYDIE is set.\nCleared by software setting the LSERDYC bit.
			LSERDYF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSIUSB48 ready interrupt flag\nSet by hardware when the HSIUSB48 clock becomes stable and HSIUSB48RDYIE is set as a response to setting HSIUSB48ON (refer to RCC clock control register (RCC_CR)). When HSIUSB48ON is not set but the HSIUSB48 oscillator is ena
			HSIUSB48RDYF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI48 ready interrupt flag\nThis flag indicates a pending interrupt upon HSI48 clock getting ready.\nSet by hardware when the HSI48 clock becomes stable and HSIRDYIE is set in response to setting the HSION (refer to RCC clock control register (RCC_CR)). Whe
			HSIRDYF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE ready interrupt flag\nThis flag indicates a pending interrupt upon HSE clock getting ready.\nSet by hardware when the HSE clock becomes stable and HSERDYIE is set.\nCleared by software setting the HSERDYC bit.
			HSERDYF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE clock security system interrupt flag\nThis flag indicates a pending interrupt upon HSE clock failure.\nSet by hardware when a failure is detected in the HSE oscillator.\nCleared by software setting the CSSC bit.
			CSSF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE clock security system interrupt flag\nThis flag indicates a pending interrupt upon LSE clock failure.\nSet by hardware when a failure is detected in the LSE oscillator.\nCleared by software by setting the LSECSSC bit.
			LSECSSF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC clock interrupt clear register
		RCC_CICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSI ready interrupt clear\nThis bit is set by software to clear the LSIRDYF flag.
			LSIRDYC {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE ready interrupt clear\nThis bit is set by software to clear the LSERDYF flag.
			LSERDYC {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSIUSB48 ready interrupt clear\nThis bit is set software to clear the HSIUSB48RDYF flag.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			HSIUSB48RDYC {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI48 ready interrupt clear\nThis bit is set software to clear the HSIRDYF flag.
			HSIRDYC {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE ready interrupt clear\nThis bit is set by software to clear the HSERDYF flag.
			HSERDYC {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock security system interrupt clear\nThis bit is set by software to clear the HSECSSF flag.
			CSSC {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE Clock security system interrupt clear\nThis bit is set by software to clear the LSECSSF flag.
			LSECSSC {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC I/O port reset register
		RCC_IOPRSTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I/O port A reset\nThis bit is set and cleared by software.
			GPIOARST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port B reset\nThis bit is set and cleared by software.
			GPIOBRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port C reset\nThis bit is set and cleared by software.
			GPIOCRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port D reset\nThis bit is set and cleared by software.
			GPIODRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port F reset\nThis bit is set and cleared by software.
			GPIOFRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC AHB peripheral reset register
		RCC_AHBRSTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1 and DMAMUX reset\nSet and cleared by software.
			DMA1RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory interface reset\nSet and cleared by software.\nThis bit can only be set when the Flash memory is in power down mode.
			FLASHRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC reset\nSet and cleared by software.
			CRCRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC APB peripheral reset register 1
		RCC_APBRSTR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM2 timer reset\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			TIM2RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM3 timer reset\nSet and cleared by software.
			TIM3RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USB reset\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			USBRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI2 reset\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			SPI2RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRS reset\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			CRSRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART2 reset\nSet and cleared by software.
			USART2RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C1 reset\nSet and cleared by software.
			I2C1RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C2 reset\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			I2C2RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Debug support reset\nSet and cleared by software.
			DBGRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Power interface reset\nSet and cleared by software.
			PWRRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC APB peripheral reset register 2
		RCC_APBRSTR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SYSCFG reset\nSet and cleared by software.
			SYSCFGRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1 timer reset\nSet and cleared by software.
			TIM1RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI1 reset\nSet and cleared by software.
			SPI1RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART1 reset\nSet and cleared by software.
			USART1RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM14 timer reset\nSet and cleared by software.
			TIM14RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer reset\nSet and cleared by software.
			TIM16RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer reset\nSet and cleared by software.
			TIM17RST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC reset\nSet and cleared by software.
			ADCRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC I/O port clock enable register
		RCC_IOPENR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I/O port A clock enable\nThis bit is set and cleared by software.
			GPIOAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port B clock enable\nThis bit is set and cleared by software.
			GPIOBEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port C clock enable\nThis bit is set and cleared by software.
			GPIOCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port D clock enable\nThis bit is set and cleared by software.
			GPIODEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port F clock enable\nThis bit is set and cleared by software.
			GPIOFEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC AHB peripheral clock enable register
		RCC_AHBENR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1 and DMAMUX clock enable\nSet and cleared by software.\nDMAMUX is enabled as long as at least one DMA peripheral is enabled.
			DMA1EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory interface clock enable\nSet and cleared by software.\nThis bit can only be cleared when the Flash memory is in power down mode.
			FLASHEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC clock enable\nSet and cleared by software.
			CRCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC APB peripheral clock enable register 1
		RCC_APBENR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM2 timer clock enable\nSet and cleared by software.
			TIM2EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM3 timer clock enable\nSet and cleared by software.
			TIM3EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC APB clock enable\nSet and cleared by software.
			RTCAPBEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WWDG clock enable\nSet by software to enable the window watchdog clock. Cleared by hardware system reset\nThis bit can also be set by hardware if the WWDG_SW option bit is 0.
			WWDGEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USB clock enable\nSet and cleared by software.
			USBEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI2 clock enable\nSet and cleared by software.
			SPI2EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRS clock enable\nSet and cleared by software.
			CRSEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART2 clock enable\nSet and cleared by software.
			USART2EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C1 clock enable\nSet and cleared by software.
			I2C1EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C2 clock enable\nSet and cleared by software.
			I2C2EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Debug support clock enable\nSet and cleared by software.
			DBGEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Power interface clock enable\nSet and cleared by software.
			PWREN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC APB peripheral clock enable register 2
		RCC_APBENR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SYSCFG clock enable\nSet and cleared by software.
			SYSCFGEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1 timer clock enable\nSet and cleared by software.
			TIM1EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI1 clock enable\nSet and cleared by software.
			SPI1EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART1 clock enable\nSet and cleared by software.
			USART1EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM14 timer clock enable\nSet and cleared by software.
			TIM14EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer clock enable\nSet and cleared by software.
			TIM16EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer clock enable\nSet and cleared by software.
			TIM17EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC clock enable\nSet and cleared by software.
			ADCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC I/O port in Sleep mode clock enable register
		RCC_IOPSMENR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I/O port A clock enable during Sleep mode\nSet and cleared by software.
			GPIOASMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port B clock enable during Sleep mode\nSet and cleared by software.
			GPIOBSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port C clock enable during Sleep mode\nSet and cleared by software.
			GPIOCSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port D clock enable during Sleep mode\nSet and cleared by software.
			GPIODSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port F clock enable during Sleep mode\nSet and cleared by software.
			GPIOFSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC AHB peripheral clock enable in Sleep/Stop mode register
		RCC_AHBSMENR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1 and DMAMUX clock enable during Sleep mode\nSet and cleared by software.\nClock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral.
			DMA1SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory interface clock enable during Sleep mode\nSet and cleared by software.\nThis bit can be activated only when the Flash memory is in power down mode.
			FLASHSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SRAM clock enable during Sleep mode\nSet and cleared by software.
			SRAMSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC clock enable during Sleep mode\nSet and cleared by software.
			CRCSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC APB peripheral clock enable in Sleep/Stop mode register 1
		RCC_APBSMENR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM2 timer clock enable during Sleep mode\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			TIM2SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM3 timer clock enable during Sleep mode\nSet and cleared by software.
			TIM3SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC APB clock enable during Sleep mode\nSet and cleared by software.
			RTCAPBSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WWDG clock enable during Sleep and Stop modes\nSet and cleared by software.
			WWDGSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USB clock enable during Sleep and Stop modes\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			USBSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI2 clock enable during Sleep and Stop modes\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			SPI2SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRS clock enable during Sleep and Stop modes\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			CRSSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART2 clock enable during Sleep and Stop modes\nSet and cleared by software.
			USART2SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C1 clock enable during Sleep and Stop modes\nSet and cleared by software.
			I2C1SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C2 clock enable during Sleep and Stop modes\nSet and cleared by software.\nNote: Only applicable on STM32C071xx, reserved on other devices.
			I2C2SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Debug support clock enable during Sleep mode\nSet and cleared by software.
			DBGSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Power interface clock enable during Sleep mode\nSet and cleared by software.
			PWRSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC APB peripheral clock enable in Sleep/Stop mode register 2
		RCC_APBSMENR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SYSCFG clock enable during Sleep and Stop modes\nSet and cleared by software.
			SYSCFGSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1 timer clock enable during Sleep mode\nSet and cleared by software.
			TIM1SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI1 clock enable during Sleep mode\nSet and cleared by software.
			SPI1SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART1 clock enable during Sleep and Stop modes\nSet and cleared by software.
			USART1SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM14 timer clock enable during Sleep mode\nSet and cleared by software.
			TIM14SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer clock enable during Sleep mode\nSet and cleared by software.
			TIM16SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer clock enable during Sleep mode\nSet and cleared by software.
			TIM17SMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC clock enable during Sleep mode\nSet and cleared by software.
			ADCSMEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC peripherals independent clock configuration register 1
		RCC_CCIPR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x54, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART1 clock source selection\nThis bitfield is controlled by software to select USART1 clock source as follows:
			USART1SEL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C1 clock source selection\nThis bitfield is controlled by software to select I2C1 clock source as follows:
			I2C1SEL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S1 clock source selection\nThis bitfield is controlled by software to select I2S1 clock source as follows:
			I2S1SEL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADCs clock source selection\nThis bitfield is controlled by software to select the asynchronous clock source for ADC:
			ADCSEL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC peripherals independent clock configuration register 2
		RCC_CCIPR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x58, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USB clock source selection\nSet and cleared by software.
			USBSEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC control/status register 1
		RCC_CSR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x5C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSE oscillator enable\nSet and cleared by software to enable LSE oscillator:
			LSEON {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE oscillator ready\nSet and cleared by hardware to indicate when the external 32 kHz oscillator is ready (stable):\nAfter the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.
			LSERDY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE oscillator bypass\nSet and cleared by software to bypass the LSE oscillator (in debug mode).\nThis bit can be written only when the external 32 kHz oscillator is disabled (LSEON=0 and LSERDY=0).
			LSEBYP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE oscillator drive capability\nSet by software to select the LSE oscillator drive capability as follows:\nApplicable when the LSE oscillator is in Xtal mode, as opposed to bypass mode.
			LSEDRV {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CSS on LSE enable\nSet by software to enable the clock security system on LSE (32 kHz) oscillator as follows:\nLSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit
			LSECSSON {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CSS on LSE failure Detection\nSet by hardware to indicate when a failure is detected by the clock security system\non the external 32 kHz oscillator (LSE):
			LSECSSD {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC clock source selection\nSet by software to select the clock source for the RTC as follows:\nOnce the RTC clock source is selected, it cannot be changed anymore unless the RTC domain is reset, or unless a failure is detected on LSE (LSECSSD is set). The 
			RTCSEL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC clock enable\nSet and cleared by software. The bit enables clock to RTC and TAMP.
			RTCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC domain software reset\nSet and cleared by software to reset the RTC domain:
			RTCRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low-speed clock output (LSCO) enable\nSet and cleared by software.
			LSCOEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low-speed clock output selection\nSet and cleared by software to select the low-speed output clock:
			LSCOSEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RCC control/status register 2
		RCC_CSR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSI oscillator enable\nSet and cleared by software to enable/disable the LSI oscillator:
			LSION {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSI oscillator ready\nSet and cleared by hardware to indicate when the LSI oscillator is ready (stable):\nAfter the LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION = 0 if the LSI is requested by t
			LSIRDY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Remove reset flags\nSet by software to clear the reset flags.
			RMVF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Option byte loader reset flag\nSet by hardware when a reset from the Option byte loading occurs.\nCleared by setting the RMVF bit.
			OBLRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Pin reset flag\nSet by hardware when a reset from the NRST pin occurs.\nCleared by setting the RMVF bit.
			PINRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BOR or POR/PDR flag\nSet by hardware when a BOR or POR/PDR occurs.\nCleared by setting the RMVF bit.
			PWRRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software reset flag\nSet by hardware when a software reset occurs.\nCleared by setting the RMVF bit.
			SFTRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Independent window watchdog reset flag\nSet by hardware when an independent watchdog reset domain occurs.\nCleared by setting the RMVF bit.
			IWDGRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Window watchdog reset flag\nSet by hardware when a window watchdog reset occurs.\nCleared by setting the RMVF bit.
			WWDGRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low-power reset flag\nSet by hardware when a reset occurs due to illegal Stop, or Standby, or Shutdown mode entry.\nCleared by setting the RMVF bit.\nThis operates only if nRST_STOP, or nRST_STDBY or nRST_SHDW option bits are cleared.
			LPWRRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief RTC address block description
	RTC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x60, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40002800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief RTC time register
		RTC_TR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Second units in BCD format
			SU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Second tens in BCD format
			ST {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute units in BCD format
			MNU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute tens in BCD format
			MNT {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour units in BCD format
			HU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour tens in BCD format
			HT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief AM/PM notation
			PM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC date register
		RTC_DR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Date units in BCD format
			DU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date tens in BCD format
			DT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Month units in BCD format
			MU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Month tens in BCD format
			MT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Week day units\n...
			WDU {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Year units in BCD format
			YU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Year tens in BCD format
			YT {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC sub second register
		RTC_SSR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Sub second value\nSS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below:\nSecond fraction = (PREDIV_S - SS) / (PREDIV_S + 1)\nNote: SS can be larger than PREDIV_S only after a shift operation. In t
			SS {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC initialization control and status register
		RTC_ICSR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alarm A write flag\nThis bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode.
			ALRAWF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Shift operation pending\nThis flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect
			SHPF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Initialization status flag\nThis bit is set by hardware when the calendar year field is different from 0 (Power-on reset state).
			INITS {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Registers synchronization flag\nThis bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF
			RSF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Initialization flag\nWhen this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
			INITF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Initialization mode
			INIT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Recalibration pending Flag\nThe RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. 
			RECALPF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC prescaler register
		RTC_PRER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Synchronous prescaler factor\nThis is the synchronous division factor:\nck_spre frequency = ck_apre frequency/(PREDIV_S+1)
			PREDIV_S {
				ec.Access : {R|W}
				ec.Size : {size : {15, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Asynchronous prescaler factor\nThis is the asynchronous division factor:\nck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
			PREDIV_A {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC control register
		RTC_CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Timestamp event active edge\nTSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
			TSEDGE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC_REFIN reference clock detection enable (50 or 60 Hz)\nNote: PREDIV_S must be 0x00FF.
			REFCKON {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bypass the shadow registers\nNote: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
			BYPSHAD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour format
			FMT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A enable
			ALRAE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief timestamp enable
			TSE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A interrupt enable
			ALRAIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp interrupt enable
			TSIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Add 1 hour (summer time change)\nWhen this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
			ADD1H {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Subtract 1 hour (winter time change)\nWhen this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0.\nSetting this bit has no effect when current hour is 0.
			SUB1H {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Backup\nThis bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Calibration output selection\nWhen COE = 1, this bit selects which signal is output on CALIB.\nThese frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to Section 24.3.14: Calibra
			COSEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output polarity\nThis bit is used to configure the polarity of TAMPALRM output.
			POL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output selection\nThese bits are used to select the flag to be routed to TAMPALRM output.
			OSEL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Calibration output enable\nThis bit enables the CALIB output
			COE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMPALRM pull-up enable
			TAMPALRM_PU {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMPALRM output type
			TAMPALRM_TYPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC_OUT2 output enable
			OUT2EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC write protection register
		RTC_WPR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Write protection key\nThis byte is written by software.\nReading this byte always returns 0x00.\nRefer to RTC register write protection for a description of how to unlock RTC register write protection.
			KEY {
				ec.Access : {W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC calibration register
		RTC_CALR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Calibration minus\nThe frequency of the calendar is reduced by masking CALM out of 2<sup>20</sup> RTCCLK pulses (32 seconds if the input frequency is 32768 Hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm.\nTo increase the f
			CALM {
				ec.Access : {R|W}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Use a 16-second calibration cycle period\nWhen CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1.\nNote: CALM[0] is stuck at 0 when CALW16 = 1. Refer to Section 24.3.12: RTC smooth digital cal
			CALW16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Use an 8-second calibration cycle period\nWhen CALW8 is set to 1, the 8-second calibration cycle period is selected.\nNote: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to Section 24.3.12: RTC smooth digital calibration.
			CALW8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Increase frequency of RTC by 488.5 ppm\nThis feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32-secon
			CALP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC shift control register
		RTC_SHIFTR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Subtract a fraction of a second\nThese bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThe value which is written to SUBFS is added to the synchronous prescal
			SUBFS {
				ec.Access : {W}
				ec.Size : {size : {15, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Add one second\nThis bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThis function is intended to be used with SUBFS (see description below) in order to effecti
			ADD1S {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC timestamp time register
		RTC_TSTR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Second units in BCD format.
			SU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Second tens in BCD format.
			ST {
				ec.Access : {R}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute units in BCD format.
			MNU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute tens in BCD format.
			MNT {
				ec.Access : {R}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour units in BCD format.
			HU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour tens in BCD format.
			HT {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief AM/PM notation
			PM {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC timestamp date register
		RTC_TSDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Date units in BCD format
			DU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date tens in BCD format
			DT {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Month units in BCD format
			MU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Month tens in BCD format
			MT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Week day units
			WDU {
				ec.Access : {R}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC timestamp sub second register
		RTC_TSSSR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Sub second value\nSS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
			SS {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC alarm A register
		RTC_ALRMAR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Second units in BCD format.
			SU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Second tens in BCD format.
			ST {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A seconds mask
			MSK1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute units in BCD format
			MNU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute tens in BCD format
			MNT {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A minutes mask
			MSK2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour units in BCD format
			HU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour tens in BCD format
			HT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief AM/PM notation
			PM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A hours mask
			MSK3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date units or day in BCD format
			DU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date tens in BCD format
			DT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Week day selection
			WDSEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A date mask
			MSK4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC alarm A sub second register
		RTC_ALRMASSR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Sub seconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
			SS {
				ec.Access : {R|W}
				ec.Size : {size : {15, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mask the most-significant bits starting at this bit\n...\nThe overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.\nNote: The overflow bits of the synchronous counter (bits 15) i
			MASKSS {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC status register
		RTC_SR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alarm A flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).
			ALRAF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp flag\nThis flag is set by hardware when a timestamp event occurs.
			TSF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp overflow flag\nThis flag is set by hardware when a timestamp event occurs while TSF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event 
			TSOVF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC masked interrupt status register
		RTC_MISR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x54, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alarm A masked flag\nThis flag is set by hardware when the alarm A interrupt occurs.
			ALRAMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp masked flag\nThis flag is set by hardware when a timestamp interrupt occurs.
			TSMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp overflow masked flag\nThis flag is set by hardware when a timestamp interrupt occurs while TSMF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time
			TSOVMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC status clear register
		RTC_SCR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x5C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clear alarm A flag\nWriting 1 in this bit clears the ALRAF bit in the RTC_SR register.
			CALRAF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear timestamp flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.
			CTSF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear timestamp overflow flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immed
			CTSOVF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief SPI address block description
	SPI1 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x22, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40013000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief SPI control register 1
		SPI_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clock phase\nNote: This bit should not be changed when communication is ongoing.\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode except the case when CRC is applied at TI mode.
			CPHA {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock polarity\nNote: This bit should not be changed when communication is ongoing.\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode except the case when CRC is applied at TI mode.
			CPOL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master selection\nNote: This bit should not be changed when communication is ongoing.\nNote: This bit is not used in I<sup>2</sup>S mode.
			MSTR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Baud rate control\nNote: These bits should not be changed when communication is ongoing.\nNote: These bits are not used in I<sup>2</sup>S mode.
			BR {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI enable\nNote: When disabling the SPI, follow the procedure described in Procedure for disabling the SPI on page 789.\nNote: This bit is not used in I<sup>2</sup>S mode.
			SPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format\nNote: 1. This bit should not be changed when communication is ongoing.\nNote: 2. This bit is not used in I<sup>2</sup>S mode and SPI TI mode.
			LSBFIRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal slave select\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored.\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode.
			SSI {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software slave management\nWhen the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode.
			SSM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive only mode enabled.\nThis bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particu
			RXONLY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC length\nThis bit is set and cleared by software to select the CRC length.\nNote: This bit should be written only when SPI is disabled (SPE =  0 ) for correct operation.\nNote: This bit is not used in I<sup>2</sup>S mode.
			CRCL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit CRC next\nNote: This bit has to be written as soon as the last data is written in the SPIx_DR register.\nNote: This bit is not used in I<sup>2</sup>S mode.
			CRCNEXT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hardware CRC calculation enable\nNote: This bit should be written only when SPI is disabled (SPE =  0 ) for correct operation.\nNote: This bit is not used in I<sup>2</sup>S mode.
			CRCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output enable in bidirectional mode\nThis bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode.\nNote: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used.\nNote: This bit is not used in I<sup>2<
			BIDIOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bidirectional data mode enable.\nThis bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active.\nNote: This bit is not used in I<sup>2</sup>S mode.
			BIDIMODE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI control register 2
		SPI_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the RXNE flag is set.
			RXDMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the TXE flag is set.
			TXDMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SS output enable\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode.
			SSOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NSS pulse management\nThis bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer.
			NSSP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format\n1 SPI TI mode\nNote: This bit must be written only when the SPI is disabled (SPE=0).\nNote: This bit is not used in I<sup>2</sup>S mode.
			FRF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupt enable\nThis bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode and UDR, OVR, and FRE in I<sup>2</sup>S mode).
			ERRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX buffer not empty interrupt enable
			RXNEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tx buffer empty interrupt enable
			TXEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data size\nThese bits configure the data length for SPI transfers.\nIf software attempts to write one of the  Not used  values, they are forced to the value  0111\n(8-bit)\nNote: These bits are not used in I<sup>2</sup>S mode.
			DS {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO reception threshold\nThis bit is used to set the threshold of the RXFIFO that triggers an RXNE event\nNote: This bit is not used in I<sup>2</sup>S mode.
			FRXTH {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last DMA transfer for reception\nThis bit is used in data packing mode, to define if the total number of data to receive by DMA is odd or even. It has significance only if the RXDMAEN bit in the SPIx_CR2 register is set and if packing mode is used (data le
			LDMA_RX {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last DMA transfer for transmission\nThis bit is used in data packing mode, to define if the total number of data to transmit by DMA is odd or even. It has significance only if the TXDMAEN bit in the SPIx_CR2 register is set and if packing mode is used (dat
			LDMA_TX {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI status register
		SPI_SR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receive buffer not empty
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit buffer empty
			TXE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel side\nNote: This bit is not used in SPI mode. It has no significance in PCM mode.
			CHSIDE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Underrun flag\nThis flag is set by hardware and reset by a software sequence. Refer to I2S error flags on page 821 for the software sequence.\nNote: This bit is not used in SPI mode.
			UDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC error flag\nNote: This flag is set by hardware and cleared by software writing 0.\nNote: This bit is not used in I<sup>2</sup>S mode.
			CRCERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mode fault\nThis flag is set by hardware and reset by a software sequence. Refer to Section : Mode fault (MODF) on page 799 for the software sequence.\nNote: This bit is not used in I<sup>2</sup>S mode.
			MODF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun flag\nThis flag is set by hardware and reset by a software sequence. Refer to I2S error flags on page 821 for the software sequence.
			OVR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Busy flag\nThis flag is set and cleared by hardware.\nNote: The BSY flag must be used with caution: refer to Section 27.5.10: SPI status flags and Procedure for disabling the SPI on page 789.
			BSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format error\nThis flag is used for SPI in TI slave mode and I<sup>2</sup>S slave mode. Refer to Section 27.5.11: SPI error flags and Section 27.7.8: I2S error flags.\nThis flag is set by hardware and reset when SPIx_SR is read by software.
			FRE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO reception level\nThese bits are set and cleared by hardware.\nNote: These bits are not used in I S mode and in SPI receive-only mode while CRC calculation is enabled.
			FRLVL {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO transmission level\nThese bits are set and cleared by hardware.\nNote: This bit is not used in I<sup>2</sup>S mode.
			FTLVL {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI data register
		SPI_DR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Data register\nData received or to be transmitted\nThe data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See Section 27.5.9: Data transmissi
			DR {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI CRC polynomial register
		SPI_CRCPR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required.
			CRCPOLY {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI Rx CRC register
		SPI_RXCRCR {
			ec.Access : {R}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rx CRC register\nWhen CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPIx_CR1 register is written to 1. The CRC is calculated serially using t
			RXCRC {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI Tx CRC register
		SPI_TXCRCR {
			ec.Access : {R}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Tx CRC register\nWhen CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPIx_CR1 is written to 1. The CRC is calculated serially using the poly
			TXCRC {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPIx_I2S configuration register
		SPI_I2SCFGR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel length (number of bits per audio channel)\nThe bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in.\nNote: For correct operation, this bit should be configure
			CHLEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data length to be transferred\nNote: For correct operation, these bits should be configured when the I2S is disabled.\nNote: They are not used in SPI mode.
			DATLEN {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Inactive state clock polarity\nNote: For correct operation, this bit should be configured when the I2S is disabled.\nNote: It is not used in SPI mode.\nNote: The bit CKPOL does not affect the CK edge sensitivity used to receive or transmit the SD and WS sign
			CKPOL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S standard selection\nFor more details on I<sup>2</sup>S standards, refer to Section 27.7.2 on page 805\nNote: For correct operation, these bits should be configured when the I2S is disabled.\nNote: They are not used in SPI mode.
			I2SSTD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PCM frame synchronization\nNote: This bit has a meaning only if I2SSTD = 11 (PCM standard is used).\nNote: It is not used in SPI mode.
			PCMSYNC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S configuration mode\nNote: These bits should be configured when the I2S is disabled.\nNote: They are not used in SPI mode.
			I2SCFG {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S enable\nNote: This bit is not used in SPI mode.
			I2SE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S mode selection\nNote: This bit should be configured when the SPI is disabled.
			I2SMOD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Asynchronous start enable.\nWhen the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and an appropriate transition is detected on the WS signal.\nWhen the I2S is enabled in slave mode, the hardware starts the tr
			ASTRTEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPIx_I2S prescaler register
		SPI_I2SPR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I2S linear prescaler\nI2SDIV [7:0] = 0 or I2SDIV [7:0] = 1 are forbidden values.\nRefer to Section 27.7.3 on page 812.\nNote: These bits should be configured when the I2S is disabled. They are used only when the I2S is in master mode.\nNote: They are not used
			I2SDIV {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Odd factor for the prescaler\nRefer to Section 27.7.3 on page 812.\nNote: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.\nNote: It is not used in SPI mode.
			ODD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master clock output enable\nNote: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.\nNote: It is not used in SPI mode.
			MCKOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief SPI address block description
	SPI2 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x22, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40003800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief SPI control register 1
		SPI_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clock phase\nNote: This bit should not be changed when communication is ongoing.\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode except the case when CRC is applied at TI mode.
			CPHA {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock polarity\nNote: This bit should not be changed when communication is ongoing.\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode except the case when CRC is applied at TI mode.
			CPOL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master selection\nNote: This bit should not be changed when communication is ongoing.\nNote: This bit is not used in I<sup>2</sup>S mode.
			MSTR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Baud rate control\nNote: These bits should not be changed when communication is ongoing.\nNote: These bits are not used in I<sup>2</sup>S mode.
			BR {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI enable\nNote: When disabling the SPI, follow the procedure described in Procedure for disabling the SPI on page 789.\nNote: This bit is not used in I<sup>2</sup>S mode.
			SPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format\nNote: 1. This bit should not be changed when communication is ongoing.\nNote: 2. This bit is not used in I<sup>2</sup>S mode and SPI TI mode.
			LSBFIRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal slave select\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored.\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode.
			SSI {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software slave management\nWhen the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode.
			SSM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive only mode enabled.\nThis bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particu
			RXONLY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC length\nThis bit is set and cleared by software to select the CRC length.\nNote: This bit should be written only when SPI is disabled (SPE =  0 ) for correct operation.\nNote: This bit is not used in I<sup>2</sup>S mode.
			CRCL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit CRC next\nNote: This bit has to be written as soon as the last data is written in the SPIx_DR register.\nNote: This bit is not used in I<sup>2</sup>S mode.
			CRCNEXT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hardware CRC calculation enable\nNote: This bit should be written only when SPI is disabled (SPE =  0 ) for correct operation.\nNote: This bit is not used in I<sup>2</sup>S mode.
			CRCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output enable in bidirectional mode\nThis bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode.\nNote: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used.\nNote: This bit is not used in I<sup>2<
			BIDIOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bidirectional data mode enable.\nThis bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active.\nNote: This bit is not used in I<sup>2</sup>S mode.
			BIDIMODE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI control register 2
		SPI_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the RXNE flag is set.
			RXDMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the TXE flag is set.
			TXDMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SS output enable\nNote: This bit is not used in I<sup>2</sup>S mode and SPI TI mode.
			SSOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NSS pulse management\nThis bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer.
			NSSP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format\n1 SPI TI mode\nNote: This bit must be written only when the SPI is disabled (SPE=0).\nNote: This bit is not used in I<sup>2</sup>S mode.
			FRF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupt enable\nThis bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode and UDR, OVR, and FRE in I<sup>2</sup>S mode).
			ERRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX buffer not empty interrupt enable
			RXNEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tx buffer empty interrupt enable
			TXEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data size\nThese bits configure the data length for SPI transfers.\nIf software attempts to write one of the  Not used  values, they are forced to the value  0111\n(8-bit)\nNote: These bits are not used in I<sup>2</sup>S mode.
			DS {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO reception threshold\nThis bit is used to set the threshold of the RXFIFO that triggers an RXNE event\nNote: This bit is not used in I<sup>2</sup>S mode.
			FRXTH {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last DMA transfer for reception\nThis bit is used in data packing mode, to define if the total number of data to receive by DMA is odd or even. It has significance only if the RXDMAEN bit in the SPIx_CR2 register is set and if packing mode is used (data le
			LDMA_RX {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last DMA transfer for transmission\nThis bit is used in data packing mode, to define if the total number of data to transmit by DMA is odd or even. It has significance only if the TXDMAEN bit in the SPIx_CR2 register is set and if packing mode is used (dat
			LDMA_TX {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI status register
		SPI_SR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receive buffer not empty
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit buffer empty
			TXE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel side\nNote: This bit is not used in SPI mode. It has no significance in PCM mode.
			CHSIDE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Underrun flag\nThis flag is set by hardware and reset by a software sequence. Refer to I2S error flags on page 821 for the software sequence.\nNote: This bit is not used in SPI mode.
			UDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC error flag\nNote: This flag is set by hardware and cleared by software writing 0.\nNote: This bit is not used in I<sup>2</sup>S mode.
			CRCERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mode fault\nThis flag is set by hardware and reset by a software sequence. Refer to Section : Mode fault (MODF) on page 799 for the software sequence.\nNote: This bit is not used in I<sup>2</sup>S mode.
			MODF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun flag\nThis flag is set by hardware and reset by a software sequence. Refer to I2S error flags on page 821 for the software sequence.
			OVR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Busy flag\nThis flag is set and cleared by hardware.\nNote: The BSY flag must be used with caution: refer to Section 27.5.10: SPI status flags and Procedure for disabling the SPI on page 789.
			BSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format error\nThis flag is used for SPI in TI slave mode and I<sup>2</sup>S slave mode. Refer to Section 27.5.11: SPI error flags and Section 27.7.8: I2S error flags.\nThis flag is set by hardware and reset when SPIx_SR is read by software.
			FRE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO reception level\nThese bits are set and cleared by hardware.\nNote: These bits are not used in I S mode and in SPI receive-only mode while CRC calculation is enabled.
			FRLVL {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO transmission level\nThese bits are set and cleared by hardware.\nNote: This bit is not used in I<sup>2</sup>S mode.
			FTLVL {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI data register
		SPI_DR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Data register\nData received or to be transmitted\nThe data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See Section 27.5.9: Data transmissi
			DR {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI CRC polynomial register
		SPI_CRCPR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required.
			CRCPOLY {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI Rx CRC register
		SPI_RXCRCR {
			ec.Access : {R}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rx CRC register\nWhen CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPIx_CR1 register is written to 1. The CRC is calculated serially using t
			RXCRC {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPI Tx CRC register
		SPI_TXCRCR {
			ec.Access : {R}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Tx CRC register\nWhen CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPIx_CR1 is written to 1. The CRC is calculated serially using the poly
			TXCRC {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPIx_I2S configuration register
		SPI_I2SCFGR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel length (number of bits per audio channel)\nThe bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in.\nNote: For correct operation, this bit should be configure
			CHLEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data length to be transferred\nNote: For correct operation, these bits should be configured when the I2S is disabled.\nNote: They are not used in SPI mode.
			DATLEN {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Inactive state clock polarity\nNote: For correct operation, this bit should be configured when the I2S is disabled.\nNote: It is not used in SPI mode.\nNote: The bit CKPOL does not affect the CK edge sensitivity used to receive or transmit the SD and WS sign
			CKPOL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S standard selection\nFor more details on I<sup>2</sup>S standards, refer to Section 27.7.2 on page 805\nNote: For correct operation, these bits should be configured when the I2S is disabled.\nNote: They are not used in SPI mode.
			I2SSTD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PCM frame synchronization\nNote: This bit has a meaning only if I2SSTD = 11 (PCM standard is used).\nNote: It is not used in SPI mode.
			PCMSYNC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S configuration mode\nNote: These bits should be configured when the I2S is disabled.\nNote: They are not used in SPI mode.
			I2SCFG {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S enable\nNote: This bit is not used in SPI mode.
			I2SE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S mode selection\nNote: This bit should be configured when the SPI is disabled.
			I2SMOD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Asynchronous start enable.\nWhen the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and an appropriate transition is detected on the WS signal.\nWhen the I2S is enabled in slave mode, the hardware starts the tr
			ASTRTEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SPIx_I2S prescaler register
		SPI_I2SPR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I2S linear prescaler\nI2SDIV [7:0] = 0 or I2SDIV [7:0] = 1 are forbidden values.\nRefer to Section 27.7.3 on page 812.\nNote: These bits should be configured when the I2S is disabled. They are used only when the I2S is in master mode.\nNote: They are not used
			I2SDIV {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Odd factor for the prescaler\nRefer to Section 27.7.3 on page 812.\nNote: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.\nNote: It is not used in SPI mode.
			ODD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master clock output enable\nNote: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.\nNote: It is not used in SPI mode.
			MCKOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Spider_SYSCFG register block
	SYSCFG {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40010000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief SYSCFG configuration register 1
		SYSCFG_CFGR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Memory mapping selection bits\nThis bitfield controlled by software selects the memory internally mapped at the address 0x0000 0000. Its reset value is determined by the boot mode configuration. Refer to Section 3: Boot configuration for more details.\nx0: 
			MEM_MODE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PA11 pin remapping\nThis bit is set and cleared by software. When set, it remaps the PA11 pin to operate as PA9 GPIO port, instead as PA11 GPIO port.\nNote: If the PINMUX2[1:0] bitfield of the SYSCFG_CFGR3 register is at 00, PA11_RMP must be kept at 0 to pr
			PA11_RMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PA12 pin remapping\nThis bit is set and cleared by software. When set, it remaps the PA12 pin to operate as PA10 GPIO port, instead as PA12 GPIO port.\nNote: If the PINMUX4[1:0] bitfield of the SYSCFG_CFGR3 register is at 00, PA12_RMP must be kept at 0 to p
			PA12_RMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IR output polarity selection
			IR_POL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IR Modulation Envelope signal selection\nThis bitfield selects the signal for IR modulation envelope:
			IR_MOD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) enable for PB6\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB6 I/O port.
			I2C_PB6_FMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) enable for PB7\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB7 I/O port.
			I2C_PB7_FMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) enable for PB8\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB8 I/O port.\nNote: Not available on STM32C011xx.
			I2C_PB8_FMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) enable for PB9\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB9 I/O port.\nNote: Not available on STM32C011xx.
			I2C_PB9_FMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) enable for I2C1\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on I/O ports configured as I2C1 through GPIOx_AFR registers.
			I2C1_FMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) enable for I2C2\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on I/O ports configured as I2C2 through GPIOx_AFR registers.\nNote: Only applicable to STM32C071xx. Reserved on the other product
			I2C2_FMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) enable for PA9\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PA9 I/O port.
			I2C_PA9_FMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) enable for PA10\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PA10 I/O port.
			I2C_PA10_FMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) enable for PC14\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PC14 I/O port.\nNote: Not available on STM32C011xx.
			I2C_PC14_FMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG configuration register 2
		SYSCFG_CFGR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Cortex<Superscript> <Default   Font>-M0+ LOCKUP enable\nThis bit is set by software and cleared by system reset. When set, it enables the connection of Cortex<Superscript> <Default   Font>-M0+ LOCKUP (HardFault) output to the TIM1/16/17 Break input.
			LOCKUP_LOCK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG configuration register 3
		SYSCFG_CFGR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Pin GPIO multiplexer 0\nThis bit is set by software and cleared by system reset. It assigns a GPIO to a pin.\n1x: Reserved\n1x: Reserved
			PINMUX0 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Pin GPIO multiplexer 1\nThis bit is set by software and cleared by system reset. It assigns a GPIO to a pin.\n1x: Reserved
			PINMUX1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Pin GPIO multiplexer 2\nThis bit is set by software and cleared by system reset. It assigns a GPIO to a pin.\n1x: Reserved\nNote: The PA11_RMP bit of the SYSCFG_CFGR1 takes priority over the selection through this bitfield. Refer to the description of the SY
			PINMUX2 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Pin GPIO multiplexer 3\nThis bit is set by software and cleared by system reset. It assigns a GPIO to a pin.\n1x: Reserved
			PINMUX3 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Pin GPIO multiplexer 4\nThis bit is set by software and cleared by system reset. It assigns a GPIO to a pin.\n1x: Reserved\nNote: The PA12_RMP bit of the SYSCFG_CFGR1 takes priority over the selection through this bitfield. Refer to the description of the SY
			PINMUX4 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Pin GPIO multiplexer 5\nThis bit is set by software and cleared by system reset. It assigns a GPIO to a pin.
			PINMUX5 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 0 status register
		SYSCFG_ITLINE0 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x80, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Window watchdog interrupt pending flag
			WWDG {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 1 status register
		SYSCFG_ITLINE1 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x84, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief V<sub>DDIO2</sub> supply monitoring interrupt request pending (EXTI line 34)
			PVM_VDDIO2_OUT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 2 status register
		SYSCFG_ITLINE2 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x88, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief RTC interrupt request pending (EXTI line 19)
			RTC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 3 status register
		SYSCFG_ITLINE3 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Flash interface interrupt request pending
			FLASH_ITF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 4 status register
		SYSCFG_ITLINE4 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x90, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Reset and clock control interrupt request pending
			RCC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRS interrupt request pending\nNote: Only applicable on STM32C071xx, reserved on other products.
			CRS {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 5 status register
		SYSCFG_ITLINE5 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x94, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI line 0 interrupt request pending
			EXTI0 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 1 interrupt request pending
			EXTI1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 6 status register
		SYSCFG_ITLINE6 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x98, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI line 2 interrupt request pending
			EXTI2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 3 interrupt request pending
			EXTI3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 7 status register
		SYSCFG_ITLINE7 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x9C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI line 4 interrupt request pending
			EXTI4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 5 interrupt request pending
			EXTI5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 6 interrupt request pending
			EXTI6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 7 interrupt request pending
			EXTI7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 8 interrupt request pending
			EXTI8 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 9 interrupt request pending
			EXTI9 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 10 interrupt request pending
			EXTI10 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 11 interrupt request pending
			EXTI11 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 12 interrupt request pending
			EXTI12 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 13 interrupt request pending
			EXTI13 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 14 interrupt request pending
			EXTI14 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI line 15 interrupt request pending
			EXTI15 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 8 status register
		SYSCFG_ITLINE8 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xA0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USB interrupt request pending
			USB {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 9 status register
		SYSCFG_ITLINE9 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xA4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1 channel 1interrupt request pending
			DMA1_CH1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 10 status register
		SYSCFG_ITLINE10 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xA8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1 channel 2 interrupt request pending
			DMA1_CH2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA1 channel 3 interrupt request pending
			DMA1_CH3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 11 status register
		SYSCFG_ITLINE11 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xAC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMAMUX interrupt request pending
			DMAMUX {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA channel 5 interrupt request pending\nNote: Only applicable on STM32C071xx, reserved on the other products.
			DMA_CH4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA channel 5 interrupt request pending\nNote: Only applicable on STM32C071xx, reserved on the other products.
			DMA_CH5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 12 status register
		SYSCFG_ITLINE12 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xB0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC interrupt request pending
			ADC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 13 status register
		SYSCFG_ITLINE13 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xB4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Timer 1 commutation interrupt request pending
			TIM1_CCU {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timer 1 trigger interrupt request pending
			TIM1_TRG {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timer 1 update interrupt request pending
			TIM1_UPD {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timer 1 break interrupt request pending
			TIM1_BRK {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 14 status register
		SYSCFG_ITLINE14 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xB8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Timer 1 capture compare interrupt request pending
			TIM1_CC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 15 status register
		SYSCFG_ITLINE15 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xBC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM2 interrupt request pending
			TIM2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 16 status register
		SYSCFG_ITLINE16 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Timer 3 interrupt request pending
			TIM3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 19 status register
		SYSCFG_ITLINE19 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xCC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Timer 14 interrupt request pending
			TIM14 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 21 status register
		SYSCFG_ITLINE21 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xD4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Timer 16 interrupt request pending
			TIM16 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 22 status register
		SYSCFG_ITLINE22 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xD8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Timer 17 interrupt request pending
			TIM17 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 23 status register
		SYSCFG_ITLINE23 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xDC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I2C1 interrupt request pending, combined with EXTI line 23
			I2C1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 24 status register
		SYSCFG_ITLINE24 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xE0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I2C2 interrupt request pending
			I2C2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 25 status register
		SYSCFG_ITLINE25 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xE4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SPI1 interrupt request pending
			SPI1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 26 status register
		SYSCFG_ITLINE26 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xE8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SPI2 interrupt request pending
			SPI2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 27 status register
		SYSCFG_ITLINE27 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xEC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART1 interrupt request pending, combined with EXTI line 25
			USART1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG interrupt line 28 status register
		SYSCFG_ITLINE28 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xF0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART2 interrupt request pending (EXTI line 26)
			USART2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief TIM1 address block description
	TIM1 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x6C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40012C00, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief TIM1 control register 1
		TIM1_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter enable\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
			CEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values.
			UDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller
			URS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One pulse mode
			OPM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Direction\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Center-aligned mode selection\nNote: Switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1) is not allowed
			CMS {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (t<sub>DTS</sub>)used by the dead-time generators and the digital filters (ETR, TIx):\nNote: t<sub>DTS</sub> = 1/f<su
			CKD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 control register 2
		TIM1_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/compare preloaded control\nNote: This bit acts only on channels that have a complementary output.
			CCPC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare control update selection\nNote: This bit acts only on channels that have a complementary output.
			CCUS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare DMA selection
			CCDS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master mode selection\nThese bits allow selected information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the mas
			MMS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI1 selection
			TI1S {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1 (OC1 output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
			OIS1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1 (OC1N output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
			OIS1N {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 2 (OC2 output)\nRefer to OIS1 bit
			OIS2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 2 (OC2N output)\nRefer to OIS1N bit
			OIS2N {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 3 (OC3 output)\nRefer to OIS1 bit
			OIS3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 3 (OC3N output)\nRefer to OIS1N bit
			OIS3N {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 4 (OC4 output)\nRefer to OIS1 bit
			OIS4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 5 (OC5 output)\nRefer to OIS1 bit
			OIS5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 6 (OC6 output)\nRefer to OIS1 bit
			OIS6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master mode selection 2\nThese bits allow the information to be sent to ADC for synchronization (TRGO2) to be selected. The combination is as follows:\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, 
			MMS2 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 slave mode control register
		TIM1_SMCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SMS[2:0]: Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nCodes above 1000: Reserve
			SMS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OCREF clear selection\nThis bit is used to select the OCREF clear source.
			OCCS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TS[2:0]: Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee Table 73: TIM1 internal trigger connection on page 395 for more details on ITRx meaning for each Timer.\nNote: These bits must b
			TS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master/slave mode
			MSM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger filter\nThis bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transi
			ETF {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger prescaler\nExternal trigger signal ETRP frequency must be at most 1/4 of f<sub>CK_INT</sub> frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
			ETPS {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External clock enable\nThis bit enables External clock mode 2.\nNote: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111).\nIt is possible to simultaneously use external clock mode 2 w
			ECE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger polarity\nThis bit selects whether ETR or ETR is used for trigger operations
			ETP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMS[3]
			SMS_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TS[4:3]
			TS_1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 DMA/interrupt enable register
		TIM1_DIER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt enable
			CC1IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt enable
			CC2IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt enable
			CC3IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt enable
			CC4IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt enable
			COMIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt enable
			TIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt enable
			BIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request enable
			CC1DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 DMA request enable
			CC2DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 DMA request enable
			CC3DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 DMA request enable
			CC4DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM DMA request enable
			COMDE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger DMA request enable
			TDE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 status register
		TIM1_SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\nWhen CNT is rei
			UIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when t
			CC1IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt flag\nRefer to CC1IF description
			CC2IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt flag\nRefer to CC1IF description
			CC3IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt flag\nRefer to CC1IF description
			CC4IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt flag\nThis flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.
			COMIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt flag\nThis flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected.
			TIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt flag\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
			BIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 interrupt flag\nThis flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.
			B2IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to  0 .
			CC1OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 overcapture flag\nRefer to CC1OF description
			CC2OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 overcapture flag\nRefer to CC1OF description
			CC3OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 overcapture flag\nRefer to CC1OF description
			CC4OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief System Break interrupt flag\nThis flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.\nThis flag must be reset to re-start PWM operation.
			SBIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Compare 5 interrupt flag\nRefer to CC1IF description (Note: Channel 5 can only be configured as output)
			CC5IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Compare 6 interrupt flag\nRefer to CC1IF description (Note: Channel 6 can only be configured as output)
			CC6IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 event generation register
		TIM1_EGR {
			ec.Access : {W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update generation\nThis bit can be set by software, it is automatically cleared by hardware.
			UG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf chann
			CC1G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 generation\nRefer to CC1G description
			CC2G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 generation\nRefer to CC1G description
			CC3G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 generation\nRefer to CC1G description
			CC4G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare control update generation\nThis bit can be set by software, it is automatically cleared by hardware\nNote: This bit acts only on channels having a complementary output.
			COMG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.
			TG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.
			BG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.
			B2G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare mode register 1
		TIM1_CCMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 Selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E =  0  in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E= 0  (TIMx_CCER register).
			IC1PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 filter\nThis bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on t
			IC1F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E =  0  in TIMx_CCER).
			CC2S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 2 prescaler\nRefer to IC1PSC[1:0] description.
			IC2PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 2 filter\nRefer to IC1F[3:0] description.
			IC2F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare mode register 1
		TIM1_CCMR1_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E =  0  in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 fast enable\nThis bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the
			OC1FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 preload enable\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S= 00  (the channel is configured in output).
			OC1PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[2:0]: Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nNote: These bits can not be 
			OC1M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 clear enable
			OC1CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E =  0  in TIMx_CCER).
			CC2S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 fast enable\nRefer to OC1FE description.
			OC2FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 preload enable\nRefer to OC1PE description.
			OC2PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC2M[2:0]: Output Compare 2 mode\nRefer to OC1M[3:0] description.
			OC2M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 clear enable\nRefer to OC1CE description.
			OC2CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[3]
			OC1M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC2M[3]
			OC2M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare mode register 2
		TIM1_CCMR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC3S bits are writable only when the channel is OFF (CC3E =  0  in TIMx_CCER).
			CC3S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 prescaler\nRefer to IC1PSC[1:0] description.
			IC3PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 filter\nRefer to IC1F[3:0] description.
			IC3F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC4S bits are writable only when the channel is OFF (CC4E =  0  in TIMx_CCER).
			CC4S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 4 prescaler\nRefer to IC1PSC[1:0] description.
			IC4PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 4 filter\nRefer to IC1F[3:0] description.
			IC4F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare mode register 2
		TIM1_CCMR2_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC3S bits are writable only when the channel is OFF (CC3E =  0  in TIMx_CCER).
			CC3S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 fast enable\nRefer to OC1FE description.
			OC3FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 preload enable\nRefer to OC1PE description.
			OC3PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC3M[2:0]: Output compare 3 mode\nRefer to OC1M[3:0] description.
			OC3M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 clear enable\nRefer to OC1CE description.
			OC3CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC4S bits are writable only when the channel is OFF (CC4E =  0  in TIMx_CCER).
			CC4S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 fast enable\nRefer to OC1FE description.
			OC4FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 preload enable\nRefer to OC1PE description.
			OC4PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC4M[2:0]: Output compare 4 mode\nRefer to OC3M[3:0] description.
			OC4M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 clear enable\nRefer to OC1CE description.
			OC4CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC3M[3]
			OC3M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC4M[3]
			OC4M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare enable register
		TIM1_CCER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output enable\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table 74 for details.\nNote: On channels having a complementary outp
			CC1E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output polarity\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP
			CC1P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output enable\nOn channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation ev
			CC1NE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output polarity\nCC1 channel configured as output:\nCC1 channel configured as input:\nThis bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description.\nNote: This bit is not writ
			CC1NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output enable\nRefer to CC1E description
			CC2E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output polarity\nRefer to CC1P description
			CC2P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 complementary output enable\nRefer to CC1NE description
			CC2NE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 complementary output polarity\nRefer to CC1NP description
			CC2NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output enable\nRefer to CC1E description
			CC3E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output polarity\nRefer to CC1P description
			CC3P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 complementary output enable\nRefer to CC1NE description
			CC3NE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 complementary output polarity\nRefer to CC1NP description
			CC3NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output enable\nRefer to CC1E description
			CC4E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output polarity\nRefer to CC1P description
			CC4P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 complementary output polarity\nRefer to CC1NP description
			CC4NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 5 output enable\nRefer to CC1E description
			CC5E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 5 output polarity\nRefer to CC1P description
			CC5P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 6 output enable\nRefer to CC1E description
			CC6E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 6 output polarity\nRefer to CC1P description
			CC6P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 counter
		TIM1_CNT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0.
			UIFCPY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 prescaler
		TIM1_PSC {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value\nThe counter clock frequency (CK_CNT) is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_
			PSC {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 auto-reload register
		TIM1_ARR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the Section 17.3.1: Time-base unit on page 331 for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.
			ARR {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 repetition counter register
		TIM1_RCR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Repetition counter value\nThese bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this in
			REP {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare register 1
		TIM1_CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 value\nIf channel CC1 is configured as output: CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE)
			CCR1 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare register 2
		TIM1_CCR2 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 2 value\nIf channel CC2 is configured as output: CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE)
			CCR2 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare register 3
		TIM1_CCR3 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare value\nIf channel CC3 is configured as output: CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). 
			CCR3 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare register 4
		TIM1_CCR4 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare value\nIf channel CC4 is configured as output: CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). 
			CCR4 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 break and dead-time register
		TIM1_BDTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Dead-time generator setup
			DTG {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock configuration\nThese bits offer a write protection against software errors.\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.
			LOCK {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Idle mode\nThis bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.\nSee OC/OCN enable description for more details (Section 17.4.11: TIM1 capture/compare enable register (TIM1_CCER)
			OSSI {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Run mode\nThis bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\nSee OC/OCN enable description for more 
			OSSR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break enable\nThis bit enables the complete break protection (including all sources connected to bk_acth and BRK sources, as per Figure 100: Break and Break2 circuitry overview).\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK
			BKE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break polarity\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic output enable\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
			AOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Main output enable\nThis bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output
			MOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break filter\nThis bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
			BKF {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 filter\nThis bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the out
			BK2F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 enable\nNote: The BRK2 must only be used with OSSR = OSSI = 1.\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to be
			BK2E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 polarity\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
			BK2P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Disarm\nThis bit is cleared by hardware when no break source is active.\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicati
			BKDSRM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break2 Disarm\nRefer to BKDSRM description
			BK2DSRM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Bidirectional\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to 
			BKBID {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break2 bidirectional\nRefer to BKBID description
			BK2BID {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 DMA control register
		TIM1_DCR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA base address\nThis 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n...
			DBA {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA burst length\nThis 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see ex
			DBL {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 DMA address for full transfer
		TIM1_DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst accesses\nA read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base add
			DMAB {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare mode register 3
		TIM1_CCMR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x54, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output compare 5 fast enable\nRefer to OC1FE description.
			OC5FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 5 preload enable\nRefer to OC1PE description.
			OC5PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC5M[2:0]: Output compare 5 mode\nRefer to OC1M description.
			OC5M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 5 clear enable\nRefer to OC1CE description.
			OC5CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 6 fast enable\nRefer to OC1FE description.
			OC6FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 6 preload enable\nRefer to OC1PE description.
			OC6PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC6M[2:0]: Output compare 6 mode\nRefer to OC1M description.
			OC6M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 6 clear enable\nRefer to OC1CE description.
			OC6CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC5M[3]
			OC5M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC6M[3]
			OC6M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare register 5
		TIM1_CCR5 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x58, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 5 value\nCCR5 is the value to be loaded in the actual capture/compare 5 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in th
			CCR5 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Group Channel 5 and Channel 1\nDistortion on Channel 1 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\nNote: it is also possible to apply this dis
			GC5C1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Group Channel 5 and Channel 2\nDistortion on Channel 2 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\nNote: it is also possible to apply this dis
			GC5C2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Group Channel 5 and Channel 3\nDistortion on Channel 3 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).\nNote: it is also possible to apply this dis
			GC5C3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 capture/compare register 6
		TIM1_CCR6 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x5C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 6 value\nCCR6 is the value to be loaded in the actual capture/compare 6 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC6PE). Else the preload value is copied in th
			CCR6 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 alternate function option register 1
		TIM1_AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRK BKIN input enable\nThis bit enables the BKIN alternate function input for the timer s BRK input. BKIN input is  ORed  with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR reg
			BKINE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK BKIN input polarity\nThis bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR regist
			BKINP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ETR source selection\nThese bits select the ETR input source.\nOthers: Reserved\nNote: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
			ETRSEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 Alternate function register 2
		TIM1_AF2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x64, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRK2 BKIN input enable\nThis bit enables the BKIN2 alternate function input for the timer s BRK2 input. BKIN2 input is  ORed  with the other BRK2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDT
			BK2INE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK2 BKIN2 input polarity\nThis bit selects the BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR re
			BK2INP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 timer input selection register
		TIM1_TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief selects TI1[0] to TI1[15] input\nOthers: Reserved
			TI1SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief selects TI2[0] to TI2[15] input\nOthers: Reserved
			TI2SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief selects TI3[0] to TI3[15] input\nOthers: Reserved
			TI3SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief selects TI4[0] to TI4[15] input\nOthers: Reserved
			TI4SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief TIM2 address block description
	TIM2 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x6C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40000000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief TIM2 control register 1
		TIM2_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter enable\n
			CEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable\n
			UDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source\n
			URS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One-pulse mode
			OPM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Direction\n
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Center-aligned mode selection\n
			CMS {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division\n
			CKD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 control register 2
		TIM2_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/compare DMA selection
			CCDS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master mode selection\n
			MMS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI1 selection
			TI1S {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 slave mode control register
		TIM2_SMCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SMS[2:0]: Slave mode selection\n
			SMS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OCREF clear selection\n
			OCCS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TS[2:0]: Trigger selection\n
			TS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master/Slave mode
			MSM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger filter\n
			ETF {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger prescaler\n
			ETPS {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External clock enable\n
			ECE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger polarity\n
			ETP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMS[3]
			SMS_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TS[4:3]
			TS_1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 DMA/Interrupt enable register
		TIM2_DIER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt enable
			CC1IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt enable
			CC2IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt enable
			CC3IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt enable
			CC4IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt enable
			TIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request enable
			CC1DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 DMA request enable
			CC2DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 DMA request enable
			CC3DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 DMA request enable
			CC4DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger DMA request enable
			TDE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 status register
		TIM2_SR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt flag\n
			UIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 interrupt flag\n
			CC1IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt flag\n
			CC2IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt flag\n
			CC3IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt flag\n
			CC4IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt flag\n
			TIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture flag\n
			CC1OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2 overcapture flag\n
			CC2OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 overcapture flag\n
			CC3OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 overcapture flag\n
			CC4OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 event generation register
		TIM2_EGR {
			ec.Access : {W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update generation\n
			UG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 generation\n
			CC1G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2 generation\n
			CC2G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 3 generation\n
			CC3G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 4 generation\n
			CC4G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger generation\n
			TG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 capture/compare mode register 1
		TIM2_CCMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 selection\n
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler\n
			IC1PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 filter\n
			IC1F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2 selection\n
			CC2S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 2 prescaler
			IC2PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 2 filter
			IC2F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 capture/compare mode register 1
		TIM2_CCMR1_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 selection\n
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 fast enable\n
			OC1FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 preload enable
			OC1PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[2:0]: Output compare 1 mode\n
			OC1M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 clear enable
			OC1CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 selection\n
			CC2S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 fast enable
			OC2FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 preload enable
			OC2PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC2M[2:0]: Output compare 2 mode\n
			OC2M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 clear enable
			OC2CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[3]
			OC1M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC2M[3]
			OC2M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 capture/compare mode register 2
		TIM2_CCMR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 3 selection\n
			CC3S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 prescaler
			IC3PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 filter
			IC3F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 selection\n
			CC4S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 4 prescaler
			IC4PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 4 filter
			IC4F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 capture/compare mode register 2
		TIM2_CCMR2_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 3 selection\n
			CC3S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 fast enable
			OC3FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 preload enable
			OC3PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC3M[2:0]: Output compare 3 mode\n
			OC3M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 clear enable
			OC3CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 selection\n
			CC4S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 fast enable
			OC4FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 preload enable
			OC4PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC4M[2:0]: Output compare 4 mode\n
			OC4M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 clear enable
			OC4CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC3M[3]
			OC3M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC4M[3]
			OC4M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 capture/compare enable register
		TIM2_CCER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output enable.
			CC1E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output Polarity.
			CC1P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output Polarity.
			CC1NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output enable.
			CC2E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output Polarity.
			CC2P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output Polarity.
			CC2NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output enable.
			CC3E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output Polarity.
			CC3P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output Polarity.
			CC3NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output enable.
			CC4E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output Polarity.
			CC4P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output Polarity.
			CC4NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 counter
		TIM2_CNT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Least significant part of counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 counter
		TIM2_CNT_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Least significant part of counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {31, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF Copy\n
			UIFCPY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 prescaler
		TIM2_PSC {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value\n
			PSC {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 auto-reload register
		TIM2_ARR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Low Auto-reload value\n
			ARR {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 capture/compare register 1
		TIM2_CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Low Capture/Compare 1 value\n
			CCR1 {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 capture/compare register 2
		TIM2_CCR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Low Capture/Compare 2 value\n
			CCR2 {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 capture/compare register 3
		TIM2_CCR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Low Capture/Compare value\n
			CCR3 {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 capture/compare register 4
		TIM2_CCR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Low Capture/Compare value\n
			CCR4 {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 DMA control register
		TIM2_DCR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA base address\n
			DBA {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA burst length\n
			DBL {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 DMA address for full transfer
		TIM2_DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst accesses\n
			DMAB {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 alternate function option register 1
		TIM2_AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ETR source selection\n
			ETRSEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM2 timer input selection register
		TIM2_TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TI1[0] to TI1[15] input selection\n
			TI1SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI2[0] to TI2[15] input selection\n
			TI2SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI3[0] to TI3[15] input selection\n
			TI3SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief TIM3 address block description
	TIM3 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x6C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40000400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief TIM3 control register 1
		TIM3_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter enable\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\nCEN is cleared automatically in one-pulse mode, when an 
			CEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values.
			UDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller
			URS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One-pulse mode
			OPM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Direction\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Center-aligned mode selection\nNote: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)
			CMS {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (ETR, TIx),
			CKD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 control register 2
		TIM3_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/compare DMA selection
			CCDS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master mode selection\nThese bits permit to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\nWhen the Counter Enable signal is controlled by the trigger input, there is a delay on T
			MMS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI1 selection
			TI1S {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 slave mode control register
		TIM3_SMCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SMS[2:0]: Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nreinitializes the counter
			SMS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OCREF clear selection\nThis bit is used to select the OCREF clear source
			OCCS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TS[2:0]: Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee Table 77: TIM3 internal trigger connection on page 478 for more details on ITRx meaning for each Timer.\nNote: These bits must b
			TS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master/Slave mode
			MSM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger filter\nThis bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transi
			ETF {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger prescaler\nExternal trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
			ETPS {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External clock enable\nThis bit enables External clock mode 2.\nNote: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111).\nNote: It is possible to simultaneously use external clock mo
			ECE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger polarity\nThis bit selects whether ETR or ETR is used for trigger operations
			ETP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMS[3]
			SMS_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TS[4:3]
			TS_1 {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 DMA/Interrupt enable register
		TIM3_DIER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt enable
			CC1IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt enable
			CC2IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt enable
			CC3IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt enable
			CC4IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt enable
			TIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request enable
			CC1DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 DMA request enable
			CC2DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 DMA request enable
			CC3DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 DMA request enable
			CC4DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger DMA request enable
			TDE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 status register
		TIM3_SR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow or underflow and if UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDI
			UIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when t
			CC1IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt flag\nRefer to CC1IF description
			CC2IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt flag\nRefer to CC1IF description
			CC3IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt flag\nRefer to CC1IF description
			CC4IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt flag\nThis flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected.
			TIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to  0 .
			CC1OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2 overcapture flag\nrefer to CC1OF description
			CC2OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 overcapture flag\nrefer to CC1OF description
			CC3OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 overcapture flag\nrefer to CC1OF description
			CC4OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 event generation register
		TIM3_EGR {
			ec.Access : {W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update generation\nThis bit can be set by software, it is automatically cleared by hardware.
			UG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf chann
			CC1G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2 generation\nRefer to CC1G description
			CC2G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 3 generation\nRefer to CC1G description
			CC3G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 4 generation\nRefer to CC1G description
			CC4G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.
			TG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 capture/compare mode register 1
		TIM3_CCMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).
			IC1PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 filter\nThis bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on t
			IC1F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).
			CC2S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 2 prescaler
			IC2PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 2 filter
			IC2F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 capture/compare mode register 1
		TIM3_CCMR1_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 fast enable\nThis bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the
			OC1FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 preload enable
			OC1PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[2:0]: Output compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nNote: In PWM mode, the OCREF
			OC1M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 clear enable
			OC1CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).
			CC2S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 fast enable
			OC2FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 preload enable
			OC2PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC2M[2:0]: Output compare 2 mode\nrefer to OC1M description on bits 6:4
			OC2M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 clear enable
			OC2CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[3]
			OC1M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC2M[3]
			OC2M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 capture/compare mode register 2
		TIM3_CCMR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).
			CC3S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 prescaler
			IC3PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 filter
			IC3F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).
			CC4S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 4 prescaler
			IC4PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 4 filter
			IC4F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 capture/compare mode register 2
		TIM3_CCMR2_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).
			CC3S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 fast enable
			OC3FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 preload enable
			OC3PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC3M[2:0]: Output compare 3 mode\nRefer to OC1M description (bits 6:4 in TIMx_CCMR1 register)
			OC3M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 clear enable
			OC3CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).
			CC4S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 fast enable
			OC4FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 preload enable
			OC4PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC4M[2:0]: Output compare 4 mode\nRefer to OC1M description (bits 6:4 in TIMx_CCMR1 register)
			OC4M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 clear enable
			OC4CE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC3M[3]
			OC3M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC4M[3]
			OC4M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 capture/compare enable register
		TIM3_CCER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output enable.
			CC1E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output Polarity.\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxF
			CC1P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output Polarity.\nCC1 channel configured as output: CC1NP must be kept cleared in this case.\nCC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
			CC1NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output enable.\nRefer to CC1E description
			CC2E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output Polarity.\nrefer to CC1P description
			CC2P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output Polarity.\nRefer to CC1NP description
			CC2NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output enable.\nRefer to CC1E description
			CC3E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output Polarity.\nRefer to CC1P description
			CC3P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output Polarity.\nRefer to CC1NP description
			CC3NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output enable.\nrefer to CC1E description
			CC4E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output Polarity.\nRefer to CC1P description
			CC4P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output Polarity.\nRefer to CC1NP description
			CC4NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 counter
		TIM3_CNT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 counter
		TIM3_CNT_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF Copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register
			UIFCPY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 prescaler
		TIM3_PSC {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value\nThe counter clock frequency CK_CNT is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EG
			PSC {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 auto-reload register
		TIM3_ARR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the Section 18.3.1: Time-base unit on page 429 for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.
			ARR {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 capture/compare register 1
		TIM3_CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE)
			CCR1 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 capture/compare register 2
		TIM3_CCR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 2 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE)
			CCR2 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 capture/compare register 3
		TIM3_CCR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare value\nIf channel CC3 is configured as output:\nCCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). 
			CCR3 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 capture/compare register 4
		TIM3_CCR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare value\nif CC4 channel is configured as output (CC4S bits):\nCCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (
			CCR4 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 DMA control register
		TIM3_DCR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA base address\nThis 5-bit vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n...\nExample: Let us con
			DBA {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA burst length\nThis 5-bit vector defines the number of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).\n...
			DBL {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 DMA address for full transfer
		TIM3_DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst accesses\nA read or write operation to the DMAR register accesses the register located at the address\n(TIMx_CR1 address) + (DBA + DMA index) x 4\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base add
			DMAB {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 alternate function option register 1
		TIM3_AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ETR source selection\nThese bits select the ETR input source.\nOthers: Reserved
			ETRSEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM3 timer input selection register
		TIM3_TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TI1[0] to TI1[15] input selection\nThese bits select the TI1[0] to TI1[15] input source.\nOthers: Reserved
			TI1SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI2[0] to TI2[15] input selection\nThese bits select the TI2[0] to TI2[15] input source.\nOthers: Reserved
			TI2SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI3[0] to TI3[15] input selection\nThese bits select the TI3[0] to TI3[15] input source.\nOthers: Reserved
			TI3SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief TIM14 address block description
	TIM14 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x6C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40002000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief TIM14 control register 1
		TIM14_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter enable\nNote: External clock and gated mode can work only if the CEN bit has been previously set by\nsoftware. However trigger mode can set the CEN bit automatically by hardware.
			CEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable\nThis bit is set and cleared by software to enable/disable update interrupt (UEV) event generation.\nCounter overflow\nSetting the UG bit.\nBuffered registers are then loaded with their preload values.
			UDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source\nThis bit is set and cleared by software to select the update interrupt (UEV) sources.\nCounter overflow\nSetting the UG bit
			URS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One-pulse mode
			OPM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (TIx),
			CKD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 Interrupt enable register
		TIM14_DIER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt enable
			CC1IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 status register
		TIM14_SR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow and if UDIS= 0  in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS= 0  and UDIS= 0  in 
			UIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when t
			CC1IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to  0 .
			CC1OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 event generation register
		TIM14_EGR {
			ec.Access : {W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update generation\nThis bit can be set by software, it is automatically cleared by hardware.
			UG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or is sent if enabled.\nIf channel CC1 is co
			CC1G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 capture/compare mode register 1
		TIM14_CCMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1).\nThe prescaler is reset as soon as CC1E= 0  (TIMx_CCER register).
			IC1PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 filter\nThis bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on t
			IC1F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 capture/compare mode register 1
		TIM14_CCMR1_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 fast enable\nThis bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the
			OC1FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 preload enable
			OC1PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[2:0]: Output compare 1 mode (refer to bit 16 for OC1M[3])\nThese bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit.\nOthers: Reserved\nNote: In PW
			OC1M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[3]
			OC1M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 capture/compare enable register
		TIM14_CCER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output enable.
			CC1E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output Polarity.\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxF
			CC1P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output Polarity.\nCC1 channel configured as output: CC1NP must be kept cleared.\nCC1 channel configured as input: CC1NP bit is used in conjunction with CC1P to define TI1FP1 polarity (refer to CC1P description).
			CC1NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 counter
		TIM14_CNT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF Copy\nThis bit is a read-only copy of the UIF bit in the TIMx_ISR register.
			UIFCPY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 prescaler
		TIM14_PSC {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value\nThe counter clock frequency CK_CNT is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event.\n(including when the counter is cleared through UG bit of TIMx_E
			PSC {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 auto-reload register
		TIM14_ARR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to Section 19.3.1: Time-base unit on page 517 for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.
			ARR {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 capture/compare register 1
		TIM14_CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE)
			CCR1 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM14 timer input selection register
		TIM14_TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief selects TI1[0] to TI1[15] input\nOthers: Reserved
			TI1SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief TIM16 address block description
	TIM16 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x6C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40014400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief TIM16 control register 1
		TIM16_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter enable\nNote: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
			CEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values.
			UDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller
			URS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One pulse mode
			OPM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (t<sub>DTS</sub>)used by the dead-time generators and the digital filters (TIx),
			CKD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 control register 2
		TIM16_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/compare preloaded control\nNote: This bit acts only on channels that have a complementary output.
			CCPC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare control update selection\nNote: This bit acts only on channels that have a complementary output.
			CCUS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare DMA selection
			CCDS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1 (OC1 output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
			OIS1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1 (OC1N output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
			OIS1N {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 DMA/interrupt enable register
		TIM16_DIER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt enable
			CC1IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt enable
			COMIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt enable
			BIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request enable
			CC1DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 status register
		TIM16_SR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by
			UIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when t
			CC1IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt flag
			COMIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt flag\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
			BIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to  0 .
			CC1OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 event generation register
		TIM16_EGR {
			ec.Access : {W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update generation\nThis bit can be set by software, it is automatically cleared by hardware.
			UG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf chann
			CC1G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare control update generation\nThis bit can be set by software, it is automatically cleared by hardware.\nNote: This bit acts only on channels that have a complementary output.
			COMG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.
			BG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 capture/compare mode register 1
		TIM16_CCMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 Selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nOthers: Reserved\nNote: CC1S bits are writable only when the channel is OFF (CC1E =  0  in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1).\nThe prescaler is reset as soon as CC1E= 0  (TIMx_CCER register).
			IC1PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 filter\nThis bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on t
			IC1F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 capture/compare mode register 1
		TIM16_CCMR1_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nOthers: Reserved\nNote: CC1S bits are writable only when the channel is OFF (CC1E =  0  in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 fast enable\nThis bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the
			OC1FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 preload enable\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S= 00  (the channel is configured in output).
			OC1PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[2:0]: Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nAll other values: Reserved\nN
			OC1M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[3]
			OC1M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 capture/compare enable register
		TIM16_CCER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output enable\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table 83 for details.
			CC1E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output polarity\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP
			CC1P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output enable
			CC1NE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output polarity\nCC1 channel configured as output:\nCC1 channel configured as input:\nThis bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer\nto the description of CC1P.\nNote: This bit is n
			CC1NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 counter
		TIM16_CNT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF Copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.
			UIFCPY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 prescaler
		TIM16_PSC {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value\nThe counter clock frequency (CK_CNT) is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_
			PSC {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 auto-reload register
		TIM16_ARR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the Section 20.3.1: Time-base unit on page 526 for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.
			ARR {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 repetition counter register
		TIM16_RCR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Repetition counter value\nThese bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this in
			REP {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 capture/compare register 1
		TIM16_CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE)
			CCR1 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 break and dead-time register
		TIM16_BDTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Dead-time generator setup\nThis bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.\nDTG[7:5] = 0xx => DT = DTG[7:0] x t<sub>dtg</sub> with t <sub>dtg</sub>= t<sub>DTS</sub>\nDTG[7:5] = 
			DTG {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock configuration\nThese bits offer a write protection against software errors.\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.
			LOCK {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Idle mode\nThis bit is used when MOE=0 on channels configured as outputs.\nSee OC/OCN enable description for more details (Section 20.4.8: TIMx capture/compare enable register (TIMx_CCER)(x = 16 to 17) on page 563).\nNote: This bit ca
			OSSI {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Run mode\nThis bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\nSee OC/OCN enable description for mo
			OSSR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break enable\n1; Break inputs (BRK and CCS clock failure event) enabled\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to b
			BKE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break polarity\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic output enable\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
			AOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Main output enable\nThis bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.\nSee OC/OCN enable de
			MOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break filter\nThis bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:\nThis bit ca
			BKF {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Disarm\nThis bit is cleared by hardware when no break source is active.\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicati
			BKDSRM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Bidirectional\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to 
			BKBID {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 DMA control register
		TIM16_DCR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA base address\nThis 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n...\nExample: Let us cons
			DBA {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA burst length\nThis 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see exa
			DBL {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 DMA address for full transfer
		TIM16_DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst accesses\nA read or write operation to the DMAR register accesses the register located at the address\n(TIMx_CR1 address) + (DBA + DMA index) x 4\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base add
			DMAB {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 alternate function register 1
		TIM16_AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRK BKIN input enable\nThis bit enables the BKIN alternate function input for the timer s BRK input. BKIN input is  ORed  with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR reg
			BKINE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK BKIN input polarity\nThis bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR regist
			BKINP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM16 input selection register
		TIM16_TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief selects TI1[0] to TI1[15] input\nOthers: Reserved
			TI1SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief TIM17 address block description
	TIM17 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x6C, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40014800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief TIM17 control register 1
		TIM17_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter enable\nNote: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
			CEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values.
			UDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller
			URS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One pulse mode
			OPM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (t<sub>DTS</sub>)used by the dead-time generators and the digital filters (TIx),
			CKD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 control register 2
		TIM17_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/compare preloaded control\nNote: This bit acts only on channels that have a complementary output.
			CCPC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare control update selection\nNote: This bit acts only on channels that have a complementary output.
			CCUS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare DMA selection
			CCDS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1 (OC1 output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
			OIS1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1 (OC1N output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
			OIS1N {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 DMA/interrupt enable register
		TIM17_DIER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt enable
			CC1IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt enable
			COMIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt enable
			BIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request enable
			CC1DE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 status register
		TIM17_SR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by
			UIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when t
			CC1IF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt flag
			COMIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt flag\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
			BIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to  0 .
			CC1OF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 event generation register
		TIM17_EGR {
			ec.Access : {W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update generation\nThis bit can be set by software, it is automatically cleared by hardware.
			UG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf chann
			CC1G {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare control update generation\nThis bit can be set by software, it is automatically cleared by hardware.\nNote: This bit acts only on channels that have a complementary output.
			COMG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.
			BG {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 capture/compare mode register 1
		TIM17_CCMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 Selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nOthers: Reserved\nNote: CC1S bits are writable only when the channel is OFF (CC1E =  0  in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1).\nThe prescaler is reset as soon as CC1E= 0  (TIMx_CCER register).
			IC1PSC {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 filter\nThis bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on t
			IC1F {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 capture/compare mode register 1
		TIM17_CCMR1_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nOthers: Reserved\nNote: CC1S bits are writable only when the channel is OFF (CC1E =  0  in TIMx_CCER).
			CC1S {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 fast enable\nThis bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the
			OC1FE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 preload enable\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S= 00  (the channel is configured in output).
			OC1PE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[2:0]: Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nAll other values: Reserved\nN
			OC1M {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M[3]
			OC1M_1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 capture/compare enable register
		TIM17_CCER {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output enable\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table 83 for details.
			CC1E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output polarity\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP
			CC1P {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output enable
			CC1NE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output polarity\nCC1 channel configured as output:\nCC1 channel configured as input:\nThis bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer\nto the description of CC1P.\nNote: This bit is n
			CC1NP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 counter
		TIM17_CNT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF Copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.
			UIFCPY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 prescaler
		TIM17_PSC {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value\nThe counter clock frequency (CK_CNT) is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_
			PSC {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 auto-reload register
		TIM17_ARR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the Section 20.3.1: Time-base unit on page 526 for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.
			ARR {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 repetition counter register
		TIM17_RCR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Repetition counter value\nThese bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this in
			REP {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 capture/compare register 1
		TIM17_CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE)
			CCR1 {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 break and dead-time register
		TIM17_BDTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Dead-time generator setup\nThis bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.\nDTG[7:5] = 0xx => DT = DTG[7:0] x t<sub>dtg</sub> with t <sub>dtg</sub>= t<sub>DTS</sub>\nDTG[7:5] = 
			DTG {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock configuration\nThese bits offer a write protection against software errors.\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.
			LOCK {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Idle mode\nThis bit is used when MOE=0 on channels configured as outputs.\nSee OC/OCN enable description for more details (Section 20.4.8: TIMx capture/compare enable register (TIMx_CCER)(x = 16 to 17) on page 563).\nNote: This bit ca
			OSSI {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Run mode\nThis bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\nSee OC/OCN enable description for mo
			OSSR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break enable\n1; Break inputs (BRK and CCS clock failure event) enabled\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to b
			BKE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break polarity\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic output enable\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
			AOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Main output enable\nThis bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.\nSee OC/OCN enable de
			MOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break filter\nThis bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:\nThis bit ca
			BKF {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Disarm\nThis bit is cleared by hardware when no break source is active.\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicati
			BKDSRM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Bidirectional\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to 
			BKBID {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 DMA control register
		TIM17_DCR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA base address\nThis 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n...\nExample: Let us cons
			DBA {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA burst length\nThis 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see exa
			DBL {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 DMA address for full transfer
		TIM17_DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst accesses\nA read or write operation to the DMAR register accesses the register located at the address\n(TIMx_CR1 address) + (DBA + DMA index) x 4\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base add
			DMAB {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 alternate function register 1
		TIM17_AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRK BKIN input enable\nThis bit enables the BKIN alternate function input for the timer s BRK input. BKIN input is  ORed  with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR reg
			BKINE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK BKIN input polarity\nThis bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR regist
			BKINP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 input selection register
		TIM17_TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief selects TI1[0] to TI1[15] input\nOthers: Reserved
			TI1SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief USART address block description
	USART1 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x30, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40013800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief USART control register 1
		USART_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by softwa
			UE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set
			UESM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver enable\nThis bit enables the receiver. It is set and cleared by software.
			RE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit ( 0  followed by  1 ) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to g
			TE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IDLE interrupt enable\nThis bit is set and cleared by software.
			IDLEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO not empty interrupt enable\nThis bit is set and cleared by software.
			RXFNEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete interrupt enable\nThis bit is set and cleared by software.
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO not-full interrupt enable\nThis bit is set and cleared by software.
			TXFNFIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PE interrupt enable\nThis bit is set and cleared by software.
			PEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the USART is d
			PS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M = 1; 8th bit if M = 0) and the parity is checked on the re
			PCE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wake-up method\nThis bit determines the USART wake-up method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			WAKE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE = 0).
			M0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode enable\nThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
			MME {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match interrupt enable\nThis bit is set and cleared by software.
			CMIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling mode\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
			OVER8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending 
			DEDT {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nThi
			DEAT {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section 26.4: USART implementation on page 691.
			RTOIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End-of-block interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			EOBIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] =  00 : 1 start bit, 8 Data bits, n Stop bit\nM[1:0] =  01 : 1 start bit, 9 Data bits, n Stop bit\nM[1:0] =  10 : 1 star
			M1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO mode enable\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not 
			FIFOEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty interrupt enable\nThis bit is set and cleared by software.
			TXFEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO full interrupt enable\nThis bit is set and cleared by software.
			RXFFIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART control register 1
		USART_CR1_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by softwa
			UE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set
			UESM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver enable\nThis bit enables the receiver. It is set and cleared by software.
			RE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit ( 0  followed by  1 ) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to g
			TE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IDLE interrupt enable\nThis bit is set and cleared by software.
			IDLEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data register not empty\nThis bit is set and cleared by software.
			RXNEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete interrupt enable\nThis bit is set and cleared by software.
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit data register empty\nThis bit is set and cleared by software.
			TXEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PE interrupt enable\nThis bit is set and cleared by software.
			PEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the USART is d
			PS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M = 1; 8th bit if M = 0) and the parity is checked on the re
			PCE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wake-up method\nThis bit determines the USART wake-up method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			WAKE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE = 0).
			M0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode enable\nThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
			MME {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match interrupt enable\nThis bit is set and cleared by software.
			CMIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling mode\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
			OVER8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending 
			DEDT {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nThi
			DEAT {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section 26.4: USART implementation on page 691.
			RTOIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of Bbock interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			EOBIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] =  00 : 1 start bit, 8 Data bits, n Stop bit\nM[1:0] =  01 : 1 start bit, 9 Data bits, n Stop bit\nM[1:0] =  10 : 1 star
			M1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO mode enable\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not 
			FIFOEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART control register 2
		USART_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Synchronous Slave mode enable\nWhen the SLVEN bit is set, the synchronous slave mode is enabled.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			SLVEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NSS pin enable\nWhen the DIS_NSS bit is set, the NSS pin input is ignored.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			DIS_NSS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 7-bit address detection/4-bit address detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\nThis bit can only be written when the USART is disabled (UE = 0)\nNote: In 7-bit and 9-bit data modes, the address detecti
			ADDM7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection length\nThis bit is for selection between 11 bit or 10 bit break detection.\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refe
			LBDL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection interrupt enable\nBreak interrupt mask (break detection using break delimiter).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			LBDIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last bit clock pulse\nThis bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the CK pin in synchronous mode.\nThe last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 o
			LBCL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock phase\nThis bit is used to select the phase of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see Figure 249 and Figure 250)\nThis bit can only be written w
			CPHA {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock polarity\nThis bit enables the user to select the polarity of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship\nThis bit can only be written when the USART is 
			CPOL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock enable\nThis bit enables the user to enable the CK pin.\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If neither synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer t
			CLKEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop bits\nThese bits are used for programming the stop bits.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			STOP {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN mode enable\nThis bit is set and cleared by software.\nThe LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.\nThis bitfield can only be written when 
			LINEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Swap TX/RX pins\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			SWAP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			RXINV {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			TXINV {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Binary data inversion\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			DATAINV {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Most significant bit first\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			MSBFIRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			ABREN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate mode\nThese bits are set and cleared by software.\nThis bitfield can only be written when ABREN = 0 or the USART is disabled (UE = 0).\nNote: If DATAINV = 1 and/or MSBFIRST = 1 the patterns must be the same on the line, for example 0xAA for MS
			ABRMOD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout enable\nThis bit is set and cleared by software.\nWhen this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).\nNote: 
			RTOEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address of the USART node\nThese bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode:\nIn Mute mode: they are used in multiprocessor communication to wake up from Mute mode with 4-bit/7-bit addr
			ADD {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART control register 3
		USART_CR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE = 1 or ORE = 1 or NE = 1 or UDR = 1 in the USART_ISR register).
			EIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IrDA mode enable\nThis bit is set and cleared by software.\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementat
			IREN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IrDA low-power\nThis bit is used for selecting between normal and low-power IrDA modes\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Sec
			IRLP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half-duplex selection\nSelection of Single-wire Half-duplex mode\nThis bit can only be written when the USART is disabled (UE = 0).
			HDSEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard NACK enable\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			NACK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard mode enable\nThis bit is used for enabling Smartcard mode.\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to S
			SCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA enable receiver\nThis bit is set/reset by software
			DMAR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA enable transmitter\nThis bit is set/reset by software
			DMAT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTS enable\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			RTSE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS enable\nThis bit can only be written when the USART is disabled (UE = 0)\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			CTSE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS interrupt enable\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			CTSIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One sample bit method enable\nThis bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.\nThis bit can only be written when the USART is disabled (UE = 0).
			ONEBIT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun disable\nThis bit is used to disable the receive overrun detection.\nthe ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is written d
			OVRDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA Disable on reception error\nThis bit can only be written when the USART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error.
			DDRE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If the Driver Enable feature is not supported, this bit is reserved a
			DEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable polarity selection\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on pa
			DEP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard auto-retry count\nThis bitfield specifies the number of retries for transmission and reception in Smartcard mode.\nIn transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit se
			SCARCNT {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (wake-up from low-power mode flag).\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: If the USART does not support t
			WUS {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode interrupt enable\nThis bit is set and cleared by software.\nNote: WUFIE must be set before entering in low-power mode.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at re
			WUFIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO threshold interrupt enable\nThis bit is set and cleared by software.
			TXFTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before guard time, interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on
			TCBGTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive FIFO threshold configuration\nRemaining combinations: Reserved
			RXFTCFG {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO threshold interrupt enable\nThis bit is set and cleared by software.
			RXFTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO threshold configuration\nRemaining combinations: Reserved
			TXFTCFG {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART baud rate register
		USART_BRR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART baud rate\nBRR[15:4]\nBRR[15:4] = USARTDIV[15:4]\nBRR[3:0]\nWhen OVER8 = 0, BRR[3:0] = USARTDIV[3:0].\nWhen OVER8 = 1:\nBRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.\nBRR[3] must be kept cleared.
			BRR {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART guard time and prescaler register
		USART_GTPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Guard time value\nThis bitfield is used to program the Guard time value in terms of number of baud clock periods.\nThis is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.\nThis bitfield can only be written when the 
			GT {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART receiver timeout register
		USART_RTOR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receiver timeout value\nThis bitfield gives the Receiver timeout value in terms of number of bits during which there is no activity on the RX line.\nIn standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected f
			RTO {
				ec.Access : {R|W}
				ec.Size : {size : {24, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Block length\nThis bitfield gives the Block length in Smartcard T = 1 Reception. Its value equals the number of information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.\nExamples:\nBLEN = 0: 0 information characters + LEC\nBLEN = 1: 0 info
			BLEN {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART request register
		USART_RQR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto baud rate request\nWriting 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame.\nNote: If the USART does not support the auto baud rate feature, this bit is reser
			ABRRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\nNote: When the application needs to send the break character following all previously inserted data, includi
			SBKRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode request\nWriting 1 to this bit puts the USART in Mute mode and resets the RWU flag.
			MMRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data flush request\nWriting 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.\nThis enables to discard the received data without reading them, and avoid an overrun condition.
			RXFRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit data flush request\nWhen FIFO mode is disabled, writing  1  to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag i
			TXFRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART interrupt and status register
		USART_ISR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\nNote: This error is associat
			PE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is se
			FE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as th
			NE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\nA
			ORE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE = 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\nNote: The IDLE bit is not set ag
			IDLE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.\nRXFNE is cleared when the RXFIFO is empty. The R
			RXFNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and when TXFE is set.\nAn interrupt is g
			TC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is fu
			TXFNF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\nNote: If the USART does not suppo
			LBDF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE = 1 in the USART_CR3 register.\nNote: 
			CTSIF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
			CTS {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\nAn interrupt is generated if RTOIE
			RTOF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of block flag\nThis bit is set by hardware when a complete block has been received (for example T = 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater tha
			EOBF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR re
			UDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not su
			ABRE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE = 1) (ABRE, RXFNE and FE are als
			ABRF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
			BUSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE = 1in the USART_CR1 register.
			CMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
			SBKF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wake-up from Mute mode\nThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 regist
			RWU {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE = 1 
			WUF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\nIt can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, 
			TEACK {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\nIt can be used to verify that the USART is ready for reception before entering low-power mode.\nNote: If the USART does not
			REACK {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty\nThis bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.\nAn interrupt is generated if th
			TXFE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO full\nThis bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the USART_RDR register.\nAn interrupt is generated if the RXFFIE bit  = 1 in the USART_CR1 register.
			RXFF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before guard time flag
			TCBGT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO threshold flag\nThis bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated
			RXFT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit  = 1 (bit 31) in the USART_CR
			TXFT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART interrupt and status register
		USART_ISR_ALTERNATE1 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.
			PE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is se
			FE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as th
			NE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXNE = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\nA
			ORE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE = 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\nNote: The IDLE bit is not set ag
			IDLE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Read data register not empty\nRXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and when TXE is set.\nAn interrupt is ge
			TC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit data register empty\nTXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the 
			TXE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\nNote: If the USART does not suppo
			LBDF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE = 1 in the USART_CR3 register.\nNote: 
			CTSIF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
			CTS {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\nAn interrupt is generated if RTOIE
			RTOF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of block flag\nThis bit is set by hardware when a complete block has been received (for example T = 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater tha
			EOBF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR re
			UDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not su
			ABRE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABRE = 1) (ABRE, RXNE and FE are also s
			ABRF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
			BUSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE = 1in the USART_CR1 register.
			CMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
			SBKF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wake-up from Mute mode\nThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 regist
			RWU {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE = 1 
			WUF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\nIt can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, 
			TEACK {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\nIt can be used to verify that the USART is ready for reception before entering low-power mode.\nNote: If the USART does not
			REACK {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before guard time flag
			TCBGT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART interrupt flag clear register
		USART_ICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Parity error clear flag\nWriting 1 to this bit clears the PE flag in the USART_ISR register.
			PECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Framing error clear flag\nWriting 1 to this bit clears the FE flag in the USART_ISR register.
			FECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the USART_ISR register.
			NECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the USART_ISR register.
			ORECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the USART_ISR register.
			IDLECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty clear flag\nWriting 1 to this bit clears the TXFE flag in the USART_ISR register.
			TXFECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the USART_ISR register.
			TCCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before Guard time clear flag\nWriting 1 to this bit clears the TCBGT flag in the USART_ISR register.
			TCBGTCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection clear flag\nWriting 1 to this bit clears the LBDF flag in the USART_ISR register.\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			LBDCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the USART_ISR register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 69
			CTSCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout clear flag\nWriting 1 to this bit clears the RTOF flag in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implemen
			RTOCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of block clear flag\nWriting 1 to this bit clears the EOBF flag in the USART_ISR register.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691
			EOBCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun clear flag\nWriting 1 to this bit clears the UDRF flag in the USART_ISR register.\nNote: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on pa
			UDRCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match clear flag\nWriting 1 to this bit clears the CMF flag in the USART_ISR register.
			CMCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the USART_ISR register.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USA
			WUCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART receive data register
		USART_RDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see Figure 243).\nWhen receiving with the parity enabled, the value read in the MSB bit is the 
			RDR {
				ec.Access : {R}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART transmit data register
		USART_TDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Transmit data value\nContains the data character to be transmitted.\nThe USART_TDR register provides the parallel interface between the internal bus and the output shift register (see Figure 243).\nWhen transmitting with the parity enabled (PCE bit set to 1 
			TDR {
				ec.Access : {R|W}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART prescaler register
		USART_PRESC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clock prescaler\nThe USART input clock can be divided by a prescaler factor:\nRemaining combinations: Reserved\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.
			PRESCALER {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief USART address block description
	USART2 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x30, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40004400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief USART control register 1
		USART_CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by softwa
			UE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set
			UESM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver enable\nThis bit enables the receiver. It is set and cleared by software.
			RE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit ( 0  followed by  1 ) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to g
			TE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IDLE interrupt enable\nThis bit is set and cleared by software.
			IDLEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO not empty interrupt enable\nThis bit is set and cleared by software.
			RXFNEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete interrupt enable\nThis bit is set and cleared by software.
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO not-full interrupt enable\nThis bit is set and cleared by software.
			TXFNFIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PE interrupt enable\nThis bit is set and cleared by software.
			PEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the USART is d
			PS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M = 1; 8th bit if M = 0) and the parity is checked on the re
			PCE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wake-up method\nThis bit determines the USART wake-up method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			WAKE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE = 0).
			M0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode enable\nThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
			MME {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match interrupt enable\nThis bit is set and cleared by software.
			CMIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling mode\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
			OVER8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending 
			DEDT {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nThi
			DEAT {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section 26.4: USART implementation on page 691.
			RTOIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End-of-block interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			EOBIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] =  00 : 1 start bit, 8 Data bits, n Stop bit\nM[1:0] =  01 : 1 start bit, 9 Data bits, n Stop bit\nM[1:0] =  10 : 1 star
			M1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO mode enable\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not 
			FIFOEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty interrupt enable\nThis bit is set and cleared by software.
			TXFEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO full interrupt enable\nThis bit is set and cleared by software.
			RXFFIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART control register 1
		USART_CR1_ALTERNATE1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x00, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by softwa
			UE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set
			UESM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver enable\nThis bit enables the receiver. It is set and cleared by software.
			RE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit ( 0  followed by  1 ) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to g
			TE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IDLE interrupt enable\nThis bit is set and cleared by software.
			IDLEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data register not empty\nThis bit is set and cleared by software.
			RXNEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete interrupt enable\nThis bit is set and cleared by software.
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit data register empty\nThis bit is set and cleared by software.
			TXEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PE interrupt enable\nThis bit is set and cleared by software.
			PEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the USART is d
			PS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M = 1; 8th bit if M = 0) and the parity is checked on the re
			PCE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wake-up method\nThis bit determines the USART wake-up method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			WAKE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE = 0).
			M0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode enable\nThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
			MME {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match interrupt enable\nThis bit is set and cleared by software.
			CMIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling mode\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
			OVER8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending 
			DEDT {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nThi
			DEAT {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section 26.4: USART implementation on page 691.
			RTOIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of Bbock interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			EOBIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] =  00 : 1 start bit, 8 Data bits, n Stop bit\nM[1:0] =  01 : 1 start bit, 9 Data bits, n Stop bit\nM[1:0] =  10 : 1 star
			M1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO mode enable\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not 
			FIFOEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART control register 2
		USART_CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x04, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Synchronous Slave mode enable\nWhen the SLVEN bit is set, the synchronous slave mode is enabled.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			SLVEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NSS pin enable\nWhen the DIS_NSS bit is set, the NSS pin input is ignored.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			DIS_NSS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 7-bit address detection/4-bit address detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\nThis bit can only be written when the USART is disabled (UE = 0)\nNote: In 7-bit and 9-bit data modes, the address detecti
			ADDM7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection length\nThis bit is for selection between 11 bit or 10 bit break detection.\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refe
			LBDL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection interrupt enable\nBreak interrupt mask (break detection using break delimiter).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			LBDIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last bit clock pulse\nThis bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the CK pin in synchronous mode.\nThe last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 o
			LBCL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock phase\nThis bit is used to select the phase of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see Figure 249 and Figure 250)\nThis bit can only be written w
			CPHA {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock polarity\nThis bit enables the user to select the polarity of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship\nThis bit can only be written when the USART is 
			CPOL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock enable\nThis bit enables the user to enable the CK pin.\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If neither synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer t
			CLKEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop bits\nThese bits are used for programming the stop bits.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			STOP {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN mode enable\nThis bit is set and cleared by software.\nThe LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.\nThis bitfield can only be written when 
			LINEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Swap TX/RX pins\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			SWAP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			RXINV {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			TXINV {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Binary data inversion\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			DATAINV {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Most significant bit first\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE = 0).
			MSBFIRST {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			ABREN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate mode\nThese bits are set and cleared by software.\nThis bitfield can only be written when ABREN = 0 or the USART is disabled (UE = 0).\nNote: If DATAINV = 1 and/or MSBFIRST = 1 the patterns must be the same on the line, for example 0xAA for MS
			ABRMOD {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout enable\nThis bit is set and cleared by software.\nWhen this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).\nNote: 
			RTOEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address of the USART node\nThese bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode:\nIn Mute mode: they are used in multiprocessor communication to wake up from Mute mode with 4-bit/7-bit addr
			ADD {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART control register 3
		USART_CR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x08, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE = 1 or ORE = 1 or NE = 1 or UDR = 1 in the USART_ISR register).
			EIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IrDA mode enable\nThis bit is set and cleared by software.\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementat
			IREN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IrDA low-power\nThis bit is used for selecting between normal and low-power IrDA modes\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Sec
			IRLP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half-duplex selection\nSelection of Single-wire Half-duplex mode\nThis bit can only be written when the USART is disabled (UE = 0).
			HDSEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard NACK enable\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			NACK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard mode enable\nThis bit is used for enabling Smartcard mode.\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to S
			SCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA enable receiver\nThis bit is set/reset by software
			DMAR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA enable transmitter\nThis bit is set/reset by software
			DMAT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTS enable\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			RTSE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS enable\nThis bit can only be written when the USART is disabled (UE = 0)\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			CTSE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS interrupt enable\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			CTSIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One sample bit method enable\nThis bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.\nThis bit can only be written when the USART is disabled (UE = 0).
			ONEBIT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun disable\nThis bit is used to disable the receive overrun detection.\nthe ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is written d
			OVRDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA Disable on reception error\nThis bit can only be written when the USART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error.
			DDRE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If the Driver Enable feature is not supported, this bit is reserved a
			DEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable polarity selection\nThis bit can only be written when the USART is disabled (UE = 0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on pa
			DEP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard auto-retry count\nThis bitfield specifies the number of retries for transmission and reception in Smartcard mode.\nIn transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit se
			SCARCNT {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (wake-up from low-power mode flag).\nThis bitfield can only be written when the USART is disabled (UE = 0).\nNote: If the USART does not support t
			WUS {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode interrupt enable\nThis bit is set and cleared by software.\nNote: WUFIE must be set before entering in low-power mode.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at re
			WUFIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO threshold interrupt enable\nThis bit is set and cleared by software.
			TXFTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before guard time, interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on
			TCBGTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive FIFO threshold configuration\nRemaining combinations: Reserved
			RXFTCFG {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO threshold interrupt enable\nThis bit is set and cleared by software.
			RXFTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO threshold configuration\nRemaining combinations: Reserved
			TXFTCFG {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART baud rate register
		USART_BRR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART baud rate\nBRR[15:4]\nBRR[15:4] = USARTDIV[15:4]\nBRR[3:0]\nWhen OVER8 = 0, BRR[3:0] = USARTDIV[3:0].\nWhen OVER8 = 1:\nBRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.\nBRR[3] must be kept cleared.
			BRR {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART guard time and prescaler register
		USART_GTPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Guard time value\nThis bitfield is used to program the Guard time value in terms of number of baud clock periods.\nThis is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.\nThis bitfield can only be written when the 
			GT {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART receiver timeout register
		USART_RTOR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receiver timeout value\nThis bitfield gives the Receiver timeout value in terms of number of bits during which there is no activity on the RX line.\nIn standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected f
			RTO {
				ec.Access : {R|W}
				ec.Size : {size : {24, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Block length\nThis bitfield gives the Block length in Smartcard T = 1 Reception. Its value equals the number of information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.\nExamples:\nBLEN = 0: 0 information characters + LEC\nBLEN = 1: 0 info
			BLEN {
				ec.Access : {R|W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART request register
		USART_RQR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto baud rate request\nWriting 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame.\nNote: If the USART does not support the auto baud rate feature, this bit is reser
			ABRRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\nNote: When the application needs to send the break character following all previously inserted data, includi
			SBKRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode request\nWriting 1 to this bit puts the USART in Mute mode and resets the RWU flag.
			MMRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data flush request\nWriting 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.\nThis enables to discard the received data without reading them, and avoid an overrun condition.
			RXFRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit data flush request\nWhen FIFO mode is disabled, writing  1  to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag i
			TXFRQ {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART interrupt and status register
		USART_ISR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\nNote: This error is associat
			PE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is se
			FE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as th
			NE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\nA
			ORE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE = 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\nNote: The IDLE bit is not set ag
			IDLE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.\nRXFNE is cleared when the RXFIFO is empty. The R
			RXFNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and when TXFE is set.\nAn interrupt is g
			TC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is fu
			TXFNF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\nNote: If the USART does not suppo
			LBDF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE = 1 in the USART_CR3 register.\nNote: 
			CTSIF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
			CTS {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\nAn interrupt is generated if RTOIE
			RTOF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of block flag\nThis bit is set by hardware when a complete block has been received (for example T = 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater tha
			EOBF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR re
			UDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not su
			ABRE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE = 1) (ABRE, RXFNE and FE are als
			ABRF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
			BUSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE = 1in the USART_CR1 register.
			CMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
			SBKF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wake-up from Mute mode\nThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 regist
			RWU {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE = 1 
			WUF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\nIt can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, 
			TEACK {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\nIt can be used to verify that the USART is ready for reception before entering low-power mode.\nNote: If the USART does not
			REACK {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty\nThis bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.\nAn interrupt is generated if th
			TXFE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO full\nThis bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the USART_RDR register.\nAn interrupt is generated if the RXFFIE bit  = 1 in the USART_CR1 register.
			RXFF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before guard time flag
			TCBGT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO threshold flag\nThis bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated
			RXFT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit  = 1 (bit 31) in the USART_CR
			TXFT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART interrupt and status register
		USART_ISR_ALTERNATE1 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.
			PE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is se
			FE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as th
			NE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXNE = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\nA
			ORE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE = 1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\nNote: The IDLE bit is not set ag
			IDLE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Read data register not empty\nRXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and when TXE is set.\nAn interrupt is ge
			TC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit data register empty\nTXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the 
			TXE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\nNote: If the USART does not suppo
			LBDF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE = 1 in the USART_CR3 register.\nNote: 
			CTSIF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
			CTS {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\nAn interrupt is generated if RTOIE
			RTOF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of block flag\nThis bit is set by hardware when a complete block has been received (for example T = 1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater tha
			EOBF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR re
			UDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not su
			ABRE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABRE = 1) (ABRE, RXNE and FE are also s
			ABRF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
			BUSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE = 1in the USART_CR1 register.
			CMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
			SBKF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wake-up from Mute mode\nThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 regist
			RWU {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE = 1 
			WUF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\nIt can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, 
			TEACK {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\nIt can be used to verify that the USART is ready for reception before entering low-power mode.\nNote: If the USART does not
			REACK {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before guard time flag
			TCBGT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART interrupt flag clear register
		USART_ICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Parity error clear flag\nWriting 1 to this bit clears the PE flag in the USART_ISR register.
			PECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Framing error clear flag\nWriting 1 to this bit clears the FE flag in the USART_ISR register.
			FECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the USART_ISR register.
			NECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the USART_ISR register.
			ORECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the USART_ISR register.
			IDLECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty clear flag\nWriting 1 to this bit clears the TXFE flag in the USART_ISR register.
			TXFECF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the USART_ISR register.
			TCCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before Guard time clear flag\nWriting 1 to this bit clears the TCBGT flag in the USART_ISR register.
			TCBGTCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection clear flag\nWriting 1 to this bit clears the LBDF flag in the USART_ISR register.\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691.
			LBDCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the USART_ISR register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 69
			CTSCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout clear flag\nWriting 1 to this bit clears the RTOF flag in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implemen
			RTOCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of block clear flag\nWriting 1 to this bit clears the EOBF flag in the USART_ISR register.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on page 691
			EOBCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun clear flag\nWriting 1 to this bit clears the UDRF flag in the USART_ISR register.\nNote: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USART implementation on pa
			UDRCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match clear flag\nWriting 1 to this bit clears the CMF flag in the USART_ISR register.
			CMCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wake-up from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the USART_ISR register.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section 26.4: USA
			WUCF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART receive data register
		USART_RDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see Figure 243).\nWhen receiving with the parity enabled, the value read in the MSB bit is the 
			RDR {
				ec.Access : {R}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART transmit data register
		USART_TDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Transmit data value\nContains the data character to be transmitted.\nThe USART_TDR register provides the parallel interface between the internal bus and the output shift register (see Figure 243).\nWhen transmitting with the parity enabled (PCE bit set to 1 
			TDR {
				ec.Access : {R|W}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief USART prescaler register
		USART_PRESC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clock prescaler\nThe USART input clock can be divided by a prescaler factor:\nRemaining combinations: Reserved\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.
			PRESCALER {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief WWDG address block description
	WWDG {
		ec.Peripheral : {0}
		ec.Size : {size : {0xC, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40002C00, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief WWDG control register
		WWDG_CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x000, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 7-bit counter (MSB to LSB)\nThese bits contain the value of the watchdog counter, decremented every\n(4096 x 2<sup>WDGTB[2:0]</sup>) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).
			T {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Activation bit\nThis bit is set by software and only cleared by hardware after a reset. When WDGA = 1, the watchdog can generate a reset.
			WDGA {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief WWDG configuration register
		WWDG_CFR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x004, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 7-bit window value\nThese bits contain the window value to be compared with the down-counter.
			W {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Early wake-up interrupt enable\nSet by software and cleared by hardware after a reset. When set, an interrupt occurs whenever the counter reaches the value 0x40.
			EWI {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timer base\nThe timebase of the prescaler can be modified as follows:
			WDGTB {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief WWDG status register
		WWDG_SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x008, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Early wake-up interrupt flag\nThis bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. Writing 1 has no effect. This bit is also set if the interrupt is not enabled.
			EWIF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
}
